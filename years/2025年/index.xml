<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2025年 on 记录每个瞬间</title>
    <link>https://code0xff.org/years/2025%E5%B9%B4/</link>
    <description>Recent content in 2025年 on 记录每个瞬间</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 04 Jan 2025 01:08:07 +0800</lastBuildDate><atom:link href="https://code0xff.org/years/2025%E5%B9%B4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spark 注册数据源</title>
      <link>https://code0xff.org/post/2025/01/spark_register_source/</link>
      <pubDate>Sat, 04 Jan 2025 01:08:07 +0800</pubDate>
      
      <guid>https://code0xff.org/post/2025/01/spark_register_source/</guid>
      <description>DataSourceRegister注册过程，自定阅读XXRelationProvider，DataSource 查找过程，DataFrameReader，DataFrameWriter，CheckpointRDDPartition，ReliableCheckpointRDD，SparkSession内部包含的变量SparkContext、sharedState、SQLContext、RuntimeConfig</description>
    </item>
    
    <item>
      <title>Spark Core相关-2</title>
      <link>https://code0xff.org/post/2025/01/spark_core_2/</link>
      <pubDate>Wed, 01 Jan 2025 01:08:07 +0800</pubDate>
      
      <guid>https://code0xff.org/post/2025/01/spark_core_2/</guid>
      <description>调度过程，RDD的主要函数，DAGScheduler将各个RDD划分到不同stage，每个Stage包含若干个TaskSet，交给内部的并发队列处理事件；TaskScheduler有点像 YARN队列，创建调度池和本地性判断，之后交给SchedulerBackend；MemoryAllocator负责分配内存，包括off-heap和on-heap，其中的MemoryBlock包含了obj指向heap的对象、以及offset和length；TaskMemoryManager负责task的内存管理，MemoryConsumer的实现类负责消费这些内存；Task包括：ShuffleMapTask、ResultTask，TaskContext 会启动新线程运行Task；AppendOnlyMap类似HashMap但做了优化，shuffle和spill的几个类：ExternalSorter、ExternalAppendOnlyMap、ShuffleExternalSorter、UnsafeExternalSorter；ShuffleWriter和实现类体系负责写磁盘，ShuffleReader主要由ShuffleBlockFetcherIterator 去抓取数据，以及管理他们的ShuffleManager；Executor 调用 launchTask，在新线程中启动 TaskRunnerTaskRunner 又会启动 Task；Master和选举；Driver调度过程，Executor分配过程，尽可能跨Worker；集群模式下TaskSchedulerImpl-&amp;gt;StandaloneSchedulerBackend-&amp;gt;StandaloneAppClinet，跟Master通讯。Master调用launchExecutor给Wroker，Worker拼接ProcessBuilder启动新进程，CoarseGrainedExecutorBackend会跟Worker通讯。YARN cluster和client模式</description>
    </item>
    
  </channel>
</rss>
