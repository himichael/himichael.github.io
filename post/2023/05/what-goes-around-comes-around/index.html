<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>What Goes Around Comes Around | 记录每个瞬间</title>
    <meta property="og:title" content="What Goes Around Comes Around - 记录每个瞬间">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2023-05-03T11:23:04&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2023-05-03T11:23:04&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="What Goes Around Comes Around">
        <meta name="author" content="隔壁老王">
        
    <meta property="og:url" content="https://code0xff.org/post/2023/05/what-goes-around-comes-around/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
        <link href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" rel="stylesheet">
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://code0xff.org/">
                        记录每个瞬间
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://code0xff.org/">首页</a>
                    
                    <a  href="https://code0xff.org/linked/" title="链接">链接</a>
                    
                    <a  href="https://code0xff.org/archives/" title="归档">归档</a>
                    
                    <a  href="https://code0xff.org/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">What Goes Around Comes Around</h1>
        </header>
        <date class="post-meta meta-date">
            2023年5月3日
        </date>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#背景">背景</a></li>
        <li><a href="#ims-era">IMS Era</a></li>
        <li><a href="#codasyl-era">CODASYL Era</a></li>
        <li><a href="#relational-era">Relational Era</a></li>
        <li><a href="#the-entity-relationship-era">The Entity-Relationship Era</a></li>
        <li><a href="#r-era">R++ Era</a></li>
        <li><a href="#the-semantic-data-model-era">The Semantic Data Model Era</a></li>
        <li><a href="#oo-era">OO Era</a></li>
        <li><a href="#the-object-relational-era">The Object-Relational Era</a></li>
        <li><a href="#semi-structured-data">Semi Structured Data</a></li>
        <li><a href="#full-circle">Full Circle</a></li>
      </ul>
    </li>
  </ul>
</nav>
        
        <div class="post-meta">
            
            <span class="post-meta meta-tags">
                <ul class="clearfix">
                    <a href='/categories/%E6%95%B0%E6%8D%AE%E5%BA%93'>数据库</a>
                </ul>
            </span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <blockquote>
<p>原文
<a href="https://15721.courses.cs.cmu.edu/spring2023/papers/01-intro/whatgoesaround-stonebraker.pdf">https://15721.courses.cs.cmu.edu/spring2023/papers/01-intro/whatgoesaround-stonebraker.pdf</a></p>
</blockquote>
<h2 id="背景">背景</h2>
<p>论文介绍了 35年的数据模型演化过程，这些模型被分成<code>9</code>个不同的时代<br>
不同时代提出的方案并非没有交集，后面的提案可能之前就出现过，所以学习历史对我们也很有帮助</p>
<p>这九个时代的数据模型包括</p>
<ul>
<li>Hierarchical (IMS): late 1960’s and 1970’s</li>
<li>Network (CODASYL): 1970’s</li>
<li>Relational: 1970’s and early 1980’s</li>
<li>Entity-Relationship: 1970’s</li>
<li>Extended Relational: 1980’s</li>
<li>Semantic: late 1970’s and 1980’s</li>
<li>Object-oriented: late 1980’s and early 1990’s</li>
<li>Object-relational: late 1980’s and early 1990’s</li>
<li>Semi-structured (XML): late 1990’s to the present</li>
</ul>
<p>这里使用一个 供应商、零件、供应量的例子来作为模型</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>Supplier (sno, sname, scity, sstate)
</span></span><span style="display:flex;"><span>Part (pno, pname, psize, pcolor)
</span></span><span style="display:flex;"><span>Supply (sno, pno, qty, price)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ims-era">IMS Era</h2>
<p>IMS (Information Management System) 是 IBM 开发的数据库管理系统<br>
最初是为了处理大型事务性应用程序而设计的<br>
这个系统非常适合处理 明确关系定义，如父子结构的数据集合<br>
按照树状结构组织<br>
比如有 Employee、Department</p>
<p>Employee 记录类型可能包含以下字段：</p>
<ul>
<li>Employee ID</li>
<li>First Name</li>
<li>Last Name</li>
<li>Hire Date</li>
</ul>
<p>Department 记录类型可能包含以下字段：</p>
<ul>
<li>Department ID</li>
<li>Department Name</li>
</ul>
<p>每个员工都必须由唯一 ID、每个部门也必须有唯一 ID<br>
每个员工都必须属于一个部门</p>
<p>层次结构的问题</p>
<ul>
<li>因为必须要有父子关系，如果一个零件是由一个供应商提供的，那么多个零件都需要指向这个供应商</li>
<li>同理，下图右边又需要重复零件的信息</li>
<li>重复数据的更新会导致可能出现不一致</li>
<li>对于边界条件，比如一个零件没有供应商，这种情况是不允许存在的

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/2.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/2.jpg" />
        </a>
    </li>
</ul>
<p>IMS 使用 DL/1 来操作数据，使用层次结构因为操作简单，有点类似于树的遍历
比如想获取 16号供应商下的 红色零件，可以这么写<br>
首先获取 供应商，然后遍历其子节点</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">Get</span> <span style="color:#ff79c6">unique</span> Supplier (sno <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">16</span>)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Until</span> failure <span style="color:#ff79c6">do</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Get</span> <span style="color:#ff79c6">next</span> within parent (color <span style="color:#ff79c6">=</span> red)
</span></span><span style="display:flex;"><span>Enddo
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以用另一种方式：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">Until</span> failure <span style="color:#ff79c6">do</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Get</span> <span style="color:#ff79c6">next</span> Part (color <span style="color:#ff79c6">=</span> red)
</span></span><span style="display:flex;"><span>Enddo
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个相当于每个节点都有一个 key，然后子节点的key是：父节点key + 子节点key 这么拼接出来的<br>
因为每个节点都key都是唯一，这样拼接出来的key 也是唯一的</p>
<p>IMS 支持多种不同的存储模型<br>
对于 root</p>
<ul>
<li>顺序存储</li>
<li>B树 存储</li>
<li>hash 存储</li>
</ul>
<p>通过 root 找到依赖的记录其存储模式</p>
<ul>
<li>物理顺序</li>
<li>各种各样的指针</li>
</ul>
<p>ISM实际是把执行逻辑，存储模型给混合在一起了，这样就导致耦合性很高<br>
应用层逻辑不能完全独立存储模型 <br>
这里有个关键词：physical data independence<br>
物理数据的更改对上层应用是独立的，不管底层怎么改动，上层都可以照常运行，但 IMS 做不到</p>
<p>不过 IMS 也支持一定程度的逻辑数据独立，它定义的是逻辑数据集，可以跟物理数据集一样<br>
当新插入物理数据后，可以重新定义逻辑数据集，将新加入的排除即可，这样逻辑数据 就是 物理数据的子集</p>
<p>上述定义的供应商、零件、供货信息 可能不适合 IMS 表示，但 IMS 也有应对策略<br>
假设物理存储结构如下：<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/3.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/3.jpg" />
        </a>
    </p>
<p>之后再定义一个 逻辑结构，将 供货信息、零件两个物理结构 连接起来，就可以解决上述问题了<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/4.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/4.jpg" />
        </a>
    <br>
这就是 层次结构用来解决 非层次结构数据的方式，不过也有很多限制<br>
比如对于删除、很复杂的场景也不好处理，这就是 IBM 未来决定支持关系数据库的原因</p>
<p>基于 IMS 的经验总结</p>
<ol>
<li>物理数据、逻辑数据独立是非常重要的</li>
<li>树结构的数据模型使用起来很严格</li>
<li>为树状结构提供复制的逻辑重组是很有挑战的</li>
<li>一条记录一次查询，每个查询都需要手动优化，使用起来很麻烦</li>
</ol>
<h2 id="codasyl-era">CODASYL Era</h2>
<p>CODASYL 委员会于 1969 - 1973年，提出了一种基于 网络的数据模型，以及一种以记录为单元的数据操作语言<br>
这种模型，将记录类型组织成一个 图结构，而不是树结构，比如 以供应商、零售商、供货记录为例<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/5.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/5.jpg" />
        </a>
     <br>
上图中包含了三种记录类型</p>
<ul>
<li>Supplier</li>
<li>Part</li>
<li>Supply</li>
</ul>
<p>在 CODASYL 中，用 命名弧线 来表示两个记录之间关系，实际就是 多对多的关系<br>
也可以用 关系数据库中的一个中间表，来模拟两个表的多对多关系</p>
<ul>
<li>Supplies，表示 Supplier 和 Supply 之间的关系，1 对多</li>
<li>Supplied_by，表示 Part 和 Supply 之间的关系，1 对多</li>
</ul>
<p>CODASYL 建立的是两个类型之间的多对多关系，是二元实体关系，如果有多个类型之间有关联<br>
则必须要拆分开来表示，比如有 新郎、新娘、牧师 之间的关系，需要用下图来表示<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/6.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/6.jpg" />
        </a>
     
所以是用 三个二元关系，来表示三元关系的，这就增加了复杂性，不过它比 IMS 更灵活</p>
<p>下面是一段遍历算法</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>Find Supplier (SNO <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">16</span>)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Until</span> <span style="color:#ff79c6">no</span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">more</span> {
</span></span><span style="display:flex;"><span> Find <span style="color:#ff79c6">next</span> Supply record <span style="color:#ff79c6">in</span> Supplies
</span></span><span style="display:flex;"><span>Find <span style="color:#ff79c6">owner</span> Part record <span style="color:#ff79c6">in</span> Supplied_by
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Get</span> <span style="color:#ff79c6">current</span> record
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">check</span> <span style="color:#ff79c6">for</span> red—
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>先定位到 Supplier 16</p>
<ul>
<li>然后，在Supplies类型子集合中查找所有与该供应商相关联的Supply类型记录，并依次处理每个Supply record</li>
<li>对于每个 Supply record，需要在 Supplied_by 类型子集合中查找其所属Part实体并获取当前record</li>
<li>最后检查该Part是否为红色零件即可完成查询过程</li>
</ul>
<p>CODASYL 需要将每个记录的入口点做 hash<br>
但这种方式是逻辑数据、物理数据紧耦合的，以你为记录之间的关系是定义在 set 集合中的<br>
set 又是存储到物理存储上的，记录了指向关系的指针<br>
所以任何结构的变更，都会改变底层的物理存储，从而影响上层的访问<br>
每次遍历都需要程序员手动维护游标</p>
<ul>
<li>最后一条被应用程序访问过的记录</li>
<li>每种实体类型最后一条被访问过的记录</li>
<li>每种集合类型最后一条被访问过的记录</li>
</ul>
<p>程序员在用游标不断遍历获取数据，对于大型的项目，甚至需要一张地图来标记当前位置和游标指针<br>
Charlie Bachman曾在1973年图灵奖颁奖典礼上提出了“导航超空间”（navigating in hyperspace）的概念</p>
<p>另一个问题是 IMS 由于是简单的父子关系，遍历时会有多次导入<br>
而 CODASYL 的多对多关系，需要一次性导入，增加导入时间<br>
而且数据损坏则需要重新加载所有数据库，与将数据划分为独立数据库的集合相比，崩溃恢复往往更复杂。</p>
<p>基于 CODASYL 的经验总结</p>
<ol>
<li>网络比层次更灵活，但更复杂</li>
<li>加载和恢复网络模型比层次模型更复杂</li>
</ol>
<h2 id="relational-era">Relational Era</h2>
<p>Codd发现 IMS 开发人员在物理、逻辑数据变更时都要花很长时间来调整数据，这使得他决定做一些修改<br>
于是就出现了关系模型，Codd 的提案有三点</p>
<ul>
<li>数据存储到一个简单的数据结构中</li>
<li>访问数据通过一种高级别的操作 DML</li>
<li>不需要对物理存储有什么建议</li>
</ul>
<p>因为逻辑、物理数据独立，并提供了高级别操作，使得 IMS，CODASYL 的那些问题就不存在了<br>
此外，关系模型还提供了更灵活的表示，对于 供应商-零件-供应信息，以及新郎-新娘-牧师 这些类型可以很好的表示</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>Ceremony (bride<span style="color:#ff79c6">-</span>id, groom<span style="color:#ff79c6">-</span>id, minister<span style="color:#ff79c6">-</span>id, other<span style="color:#ff79c6">-</span><span style="color:#ff79c6">data</span>)
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后 Codd 在 SIGMOD，以及 SIGFIDET 跟 CODASYL 的支持者做了很长时间的辩论<br>
Codd的观点是</p>
<ul>
<li>CODASYL模型很复杂，而且对于像婚姻这种常见的场景都表示不好</li>
<li>逻辑数据、物理数据耦合，导致编程很复杂</li>
</ul>
<p>之后的很多年里双方都认识到了自身的问题，也做了修改</p>
<p>再看商业市场，IBM 最开始卖的是基于大型机的 IMS，后来小型机，个人电脑出现  <br>
层次模型和 CODASYL失败了<br>
IBM 当时想采用 SQL作为前端，后端继续对接 IMS，但是发现这两种模型并不匹配，强加在一起其实是很困难的<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/7.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/7.jpg" />
        </a>
    </p>
<p>到 1984年推出了 DB2，IBMS 开始采用双数据库策略，同时搞两个产品<br>
但是 DB/2 明显更简单，更有未来前景
当时 IBM 在数据库市场有巨大的份额，他宣布的结果基本上就判定了 关系数据库赢得了胜利</p>
<p>从这场争论到市场化，我们可以学到</p>
<ul>
<li>不管数据模型怎么变，使用 Set-a-time(基于时间戳变更的方式而不是覆盖)，提供了更好的物理数据独立性</li>
<li>简单模型比复杂模型更容易实现数据独立</li>
<li>技术的争论通常由市场的实际需求和其他因素决定胜负，这与技术本身无关，所以技术发展受到商业和社会的影响</li>
<li>查询优化器的效果，比人工优化的效果更好</li>
</ul>
<h2 id="the-entity-relationship-era">The Entity-Relationship Era</h2>
<p>这是在 1970年代中期被提出来的，作为 关系模型、层次模型、CODASYL 的替代<br>
在实体关系模型中，数据集就是 实体实例的集合，实体之间彼此是独立的<br>
比如</p>
<ul>
<li>Supplier 就是实体</li>
<li>Parts 也是实体</li>
</ul>
<p>实体可以有属性，比如 Parts包含：pno、pname、psize、pcolor<br>
还有一个或者多个唯一的属性，如 key<br>
实体之间可以有关系，这个关系是 1-1、1-N、N-1、或者是 M-N 的<br>
比如 Supplier 和 Parts 之间的关系，就是 M-N 的<br>
关系也有属性，比如qty、price等</p>
<p>不过 E-R模型并没有做到 数据库底层的数据模型</p>
<ul>
<li>可能是当时没有支持它的查询语言</li>
<li>或者是当时被关系模型的出现所掩盖了</li>
<li>或者某些地方看起来太像 CODASYL 模型了</li>
</ul>
<p>E-R 模型中用方框和尖头来表示<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/8.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/8.jpg" />
        </a>
    </p>
<p>E-R模型在数据库模型设计上取得了巨大的成功<br>
当时关系模型的倡导者建提出了各种理论，比如 第二、第三、第四范式<br>
但这些理论 对于 DBA 帮助不大<br>
而使用 E-R模型，用来构建表的结构，转换为 第三范式就狠简单</p>
<p>总结</p>
<ul>
<li>功能依赖对于普通人来说难以理解，KISS 保持简单是很重要的</li>
</ul>
<h2 id="r-era">R++ Era</h2>
<p>1970年代除了一些 parper，他们的主要目的是对关系模型的一些改进<br>
这些研究包括</p>
<ul>
<li>CAD</li>
<li>VLSI CAD</li>
<li>文本管理</li>
<li>时间</li>
<li>电脑绘图</li>
</ul>
<p>这里有一些比较好的扩展属性</p>
<ul>
<li>set-valued 属性，比如一个零件可以由多种颜色，这些颜色表示这个属性的集合值，或者是用户的爱好标签也是类似的</li>
<li>aggregation，类似SQL语法中的聚合</li>
<li>generalization，允许有继承关系
比如 Supply (PT, SR, qty, price)，PT来自 part表，SR来自Supplier表<br>
可以使用如下SQL</li>
</ul>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">Select</span> Supply.SR.sno
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">From</span> Supply
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Where</span> Supply.PT.pcolor <span style="color:#ff79c6">=</span> “red”
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种查询方式于 网络语言中的 路径表示方式
“Supply.SR.sno”指代 Supply 表格和 Supplier 表格之间存在外键关系，并且通过 SR 属性引用了 Supplier 表格中与当前记录相关联的供应商信息<br>
&ldquo;Supply.PT.pcolor&rdquo; 指代 Supply 和 Part 两张表之间存在外键关系，并且通过 PT 属性引用了 Part 表格中与当前记录相关联零件信息<br>
WHERE 子句中使用 &ldquo;pcolor = &lsquo;red&rsquo;&rdquo; 条件过滤出所有颜色为红色（即 pcolor 列等于 &ldquo;red&rdquo;） 的零件所对应供应商编号 sno</p>
<p>泛化的继承关系如下，电器零件、管道零件都有相似的属性<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/9.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/9.jpg" />
        </a>
    </p>
<p>总结的经验</p>
<ul>
<li>除非有很大的性能或功能优势，否则新的构造将无处可去</li>
</ul>
<h2 id="the-semantic-data-model-era">The Semantic Data Model Era</h2>
<p>这种观点是，关系模型对于某些类型不好表示，于是出现了一种新的方案，叫做 post relational 数据模型 <br>
也叫做 语义模型<br>
语义模型关注的是类别，跟R++模型类似，提出了 聚合、泛化、集合的概念<br>
通过允许类具有作为其他类中的记录的属性来支持聚合</p>
<p>多重继承是SDM中的常见构造。类还可以是其他类之间的并集、交集或差集。<br>
类还可以是另一个类的子类，由谓词确定成员资格  <br>
一个类也可以是由于某种原因而被分组在一起的记录集合<br>
类可以有类变量，例如Ships类可以有一个类变量，它是类成员的数量<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/10.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2023/04/What%20Goes%20Around%20Comes%20Around/10.jpg" />
        </a>
     
上图展示了一个 多重继承<br>
在这个例子中，有三个类</p>
<ul>
<li>Oil_tankers</li>
<li>American_ships</li>
<li>American_oil_tankers</li>
</ul>
<p>其中，Oil_tankers是所有油轮船只的父类（即最一般化）<br>
而 American_ships 是所有美国船只 的父类<br>
A merican_oil_ tank ers 继承了 Oil _tank ers 和 A merican_s hips 这两个类 <br>
因此它拥有这两者的属性<br>
一个子类可以同时拥有多个父类，并且从每一个父级那里都可以获得属性和方法等信息</p>
<p>这个模型太复杂，后续几乎没有什么影响力</p>
<h2 id="oo-era">OO Era</h2>
<p>出现在 1980年代，用来解决程序语言如C++ 和 关系数据库之间的阻抗不匹配问题<br>
编程语言有他们自己的命名系统，数据类型，这和关系数据库之间并不匹配<br>
比如用 C++定义的零件</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Struct Part {
</span></span><span style="display:flex;"><span>Int number;
</span></span><span style="display:flex;"><span>Char<span style="color:#ff79c6">*</span> name;
</span></span><span style="display:flex;"><span>Char<span style="color:#ff79c6">*</span> bigness;
</span></span><span style="display:flex;"><span>Char<span style="color:#ff79c6">*</span> color;
</span></span><span style="display:flex;"><span>} Example_part;
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后用关系数据库做查询，然后将结果绑定到 结构体的变量中</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>Define <span style="color:#ff79c6">cursor</span> P <span style="color:#ff79c6">as</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Select</span> <span style="color:#ff79c6">*</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">From</span> Part
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Where</span> pno <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">16</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Open</span> P <span style="color:#ff79c6">into</span> Example_part
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Until</span> <span style="color:#ff79c6">no</span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">more</span>{
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Fetch</span> P (Example_part.<span style="color:#8be9fd;font-style:italic">number</span> <span style="color:#ff79c6">=</span> pno,
</span></span><span style="display:flex;"><span>Example_name <span style="color:#ff79c6">=</span> pname
</span></span><span style="display:flex;"><span>Example_part.bigness <span style="color:#ff79c6">=</span> psize
</span></span><span style="display:flex;"><span>Example_part.color <span style="color:#ff79c6">=</span> pcolor)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>有些语言，允许将 变量持久化，这变成了这样：</p>
<pre tabindex="0"><code>For P in Part where P.pno = 16{
    Code_to_manipulate_part
}
</code></pre><p>允许以 程序语言的方式 做loop，但是需要做编译器扩展<br>
而且每种语言的每个编译器都需要做一次扩展<br>
而编程语言设计者一般不关注 I/O 方面的问题，所以也没有内置的库函数<br>
到 1980年代开始为 C++做相关 OODB的扩展</p>
<p>比如一个 CAD程序，需要先打开，然后执行一些操作，关闭后会自动保存写入<br>
对于这种情况，需要 C++将内存地址映射，以及磁盘地址映射关联起来<br>
对于事务，查询语言的关注度就没那么高了，而且需要跟传统的C++ 编译器做竞争</p>
<p>失败的原因如下</p>
<ul>
<li>仅仅只是自定义的加载和卸载，这种功能不算多强，用户未必买单</li>
<li>各种 OODB 不兼容，没有标准化</li>
<li>一旦做了修改，调用的逻辑还需要重新链接</li>
<li>非 C++ 生态不能使用</li>
<li>和用户逻辑在同一地址空间，安全和认证不好做，有隐患</li>
</ul>
<p>O2 公司还做了一个 OQL的高级声明性语言嵌入到编程语言中<br>
但他们的商业策略有问题，他们是法国公司，但主打美国市场，没有获得风投支持，失去市场</p>
<p>经验总结</p>
<ul>
<li>除非用户真正出现了很大问题(比如编程语言和DB的严重阻抗不匹配)，他们非常想解决这些问题，软件才有市场</li>
<li>没有编程语言社区的支持，想在语言上做出什么大突破不太可能</li>
</ul>
<h2 id="the-object-relational-era">The Object-Relational Era</h2>
<p>这是在 1982 年出现的，来自于一个简单的需求<br>
假设有一个 GIS系统在表中这么记录的</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>Intersections (I<span style="color:#ff79c6">-</span>id, long, lat, other<span style="color:#ff79c6">-</span><span style="color:#ff79c6">data</span>)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果要在一个边界内找到  (X0, Y0, X1, Y1) 的所有交点，则</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">Select</span> I<span style="color:#ff79c6">-</span>id
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">From</span> Intersections
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Where</span> X0 <span style="color:#ff79c6">&lt;</span> long <span style="color:#ff79c6">&lt;</span> X1 <span style="color:#ff79c6">and</span> Y0 <span style="color:#ff79c6">&lt;</span> lat <span style="color:#ff79c6">&lt;</span> Y1
</span></span></code></pre></td></tr></table>
</div>
</div><p>POSTGRE 是用 B树存储的，是一维的，而这里是多维度的，很难表示，也很难高效的查询</p>
<p>另一种情况是要查询 土地拥有者<br>
Parcel (P-id, Xmin, Xmax, Ymin, Ymax) <br>
找到所有跟这个 矩形有相交的，然后通知他们</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">Select</span> P<span style="color:#ff79c6">-</span>id
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">From</span> Parcel
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Where</span> Xmax <span style="color:#ff79c6">&gt;</span> X0 <span style="color:#ff79c6">and</span> Ymax <span style="color:#ff79c6">&gt;</span> Y0 <span style="color:#ff79c6">and</span> Xmin <span style="color:#ff79c6">&lt;</span> X1 <span style="color:#ff79c6">and</span> Ymax <span style="color:#ff79c6">&lt;</span> Y1
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种查询在 SQL 上很难表示，而且性能非常差</p>
<p>一个 OR提案可能会增加</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">user</span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">defined</span> <span style="color:#ff79c6">data</span> types,
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">user</span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">defined</span> operators,
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">user</span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">defined</span> functions, <span style="color:#ff79c6">and</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">user</span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">defined</span> <span style="color:#ff79c6">access</span> methods
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于上述问题，修改后的SQL是</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">Select</span> I<span style="color:#ff79c6">-</span>id
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">From</span> Intersections
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Where</span> point <span style="color:#ff79c6">!!</span> “X0, X1, Y0, Y1”
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Select</span> P<span style="color:#ff79c6">-</span>id
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">From</span> Parcel
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">Where</span> P<span style="color:#ff79c6">-</span>box <span style="color:#ff79c6">##</span> “X0, X1, Y0, Y1”
</span></span></code></pre></td></tr></table>
</div>
</div><p>!! “X0, X1, Y0, Y1” 表示 点范围<br>
## “X0, X1, Y0, Y1” 表示矩形范围<br>
为支持这些操作，需要增加自定义的类型，自定义的操作<br>
需要增加 Quad-trees，以及 R-trees<br>
这些就是 POSTGRE 的贡献</p>
<p>此外还有 Sybase 支持了 存储过程</p>
<ul>
<li>Postgres数据库管理系统的实现和商业成功，它是Object-Relational（OR）时代的一部分。</li>
<li>Postgres实现了用户定义数据类型（UDT）、用户定义函数（UDF）和用户定义访问方法，</li>
<li>以允许定制DBMS以满足特定市场需求，例如在地理信息系统中</li>
<li>此外，它还实现了继承、指针、集合和数组等较不复杂的概念构造器来使其成为“面向对象”的数据库。</li>
<li>后来进行基准测试表明，在Postgres中UDT和UDF是主要优势所在</li>
<li>而内置聚合与泛化支持对性能提升帮助有限</li>
<li>OR模型已经取得一些商业上的成功案例, 其中Illustra就是一个例子</li>
</ul>
<p>这个时代 Informix 也比较成功<br>
OR 模型的问题是，很多厂商之间不兼容，有他们独自的 UDF 功能</p>
<p>经验总结</p>
<ul>
<li>OR模型的主要好处，将代码放入数据集，模糊了数据和代码的不同；UDF 功能</li>
<li>新技术的推广，需要标准化，或者大力度的推广</li>
</ul>
<h2 id="semi-structured-data">Semi Structured Data</h2>
<p>DB 的数据需要提前定义好模式，然后才能写入<br>
而有些数据可以不用事先定义模式，这些数据往往有自解释的模式<br>
一般叫做：schema last 的系统，如果没有自描述，则变成了一堆bit</p>
<p>需要在属性上定义一些元数据来描述这些数据，比如</p>
<pre tabindex="0"><code>Person:
Name: Joe Jones
Wages: 14.75
Employer: My_accounting
Hobbies: skiing, bicycling
Works for: ref (Fred Smith)
Favorite joke: Why did the chicken cross the road? To get to the other side
Office number: 247
Major skill: accountant
End Person
Person:
Name: Smith, Vanessa
Wages: 2000
Favorite coffee: Arabian
Passtimes: sewing, swimming
Works_for: Between jobs
Favorite restaurant: Panera
Number of children: 3
End Person
</code></pre><p>上面定了两个 person，但是他们的属性并不相同<br>
这就给查询和使用带来了困难和挑战，他们叫做： semantic heterogeneity   <br>
schema last主要适用于以自由文本为数据输入机制的应用程序</p>
<p>为有效利用 schema-last，将应用分类四类</p>
<ul>
<li>有严格结构化的数据</li>
<li>有严格结构化数据，以及一些文本字段数据</li>
<li>半结构化数据</li>
<li>文本数据</li>
</ul>
<p>比如工资单，这种不允许错误，不允许出现格式问题，就必须要严格的格式，需要schema-first<br>
另一种比如员工信息，大部分需要严格格式，有些字段如上一家的主管评价可以是自由文本，这就是第二种分类</p>
<p>广告、简历则需要半结构化，因为没有公用的部分，这时候可以自解释，然后提取出需要的信息即可<br>
第四类是文本信息检索，他们没有模式</p>
<p>除了广告、简历之外，很少有符合第三类的数据模式，也就是说第三类的应用很少，相反第二类的则会很多 <br>
另外这类的应用，似乎只适合处理少量的数据</p>
<p>XML模型则是目前最复杂的模型，包含了之前出现过的所有特性</p>
<ul>
<li>类似 IMS的层次结构</li>
<li>包含link 到其他记录，类似CODASYL</li>
<li>包含一个属性数据集，类似SDM</li>
<li>带有继承特点，类似SDM</li>
</ul>
<p>此外它还有联合类型，如果一个联合类型包含了 N、M中类型，那么如果做 join的话<br>
其查询计划就需要只要有 max(N, M) 种，大大增加了复杂度，所以union 类型从来没有在 DB 中被考虑过</p>
<p>经验总结</p>
<ul>
<li>schema-last 可能只合适小部分场景</li>
<li>XQuery相当于是 SQL的扩展</li>
<li>XML不能解决企业内部、跨企业的语义异构问题，即使是薪资，可能是法国税后包含午餐津贴、另一个是美国税前，没有比较性</li>
</ul>
<h2 id="full-circle">Full Circle</h2>
<p>历史就是一个轮回，30多年的数据模型发展历史，先是从复杂的模型开始<br>
然后是 复杂模型 vs 简单模型 的大辩论，简单模型易于使用最后获胜</p>
<p>随后就是一系列的功能增强，但这些没能吸引市场，因为增加了很多复杂度，但却没能带来更多的好处<br>
只有 UDF，以及自定义访问方式 能吸引人注意<br>
而当前的功能是之前的超集，所以我们相当于是绕了一圈</p>
<p>XML 的倡导者 vs 关系模型，跟 第一场大辩论，关系模型 vs CODASYL 很类似<br>
有点像 关系模型 vs  CODASYL-2，但 CODASYL-2比之前的更复杂，想做到数据独立就更困难<br>
从历史来看，如果原生的 XML 数据库获得关注，那么逻辑数据独立、复杂性方面的问题依然会出现</p>
<p>大多数新发明则是对过去的模型的重新发明而已，唯一值得注意的概念是</p>
<ul>
<li>Code in the data base (from the OR camp)</li>
<li>Schema last (from the semi-structured data camp)</li>
</ul>
<p>不过 schema-last 只是用于小众领域<br>
而 code in DB 的想法不错，让数据和代码变得平等了</p>

			<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
        </div>

        


        

<div class="post-archive">
    <h2>相关文章</h2>
    <ul class="listing">
        
        <li><a href="/post/2023/02/cpu-and-cache-efficient-management-of-memory-resident-databases/">CPU and Cache Efficient Management of Memory-Resident Databases</a></li>
        
        <li><a href="/post/2023/02/efficiently-compiling-efficient-query-plans-for-modern-hardware/">Efficiently Compiling Efficient Query Plans for Modern Hardware</a></li>
        
        <li><a href="/post/2023/02/generating-code-for-holistic-query-evaluation/">Generating code for holistic query evaluation</a></li>
        
        <li><a href="/post/2023/02/implementing-database-operations-using-simd-instructions/">Implementing Database Operations Using SIMD Instructions</a></li>
        
        <li><a href="/post/2023/01/rethinking-simd-vectorization-for-in-memory-databases/">Rethinking SIMD Vectorization for In-Memory Databases</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/%E8%AE%BA%E6%96%87'>论文</a></li>
                
                <li><a href='/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B'>数据模型</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "himichael/hugoblogtalks"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>


                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://code0xff.org/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://code0xff.org/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://code0xff.org/post/2023/09/xsimd/" title="xsimd">xsimd</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/09/ambari/" title="Ambari架构">Ambari架构</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/08/gluten%E5%92%8C%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96/" title="Gluten和相关依赖">Gluten和相关依赖</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/07/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/" title="大数据采集">大数据采集</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/07/jvm-gc/" title="JVM GC 介绍">JVM GC 介绍</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/07/presto%E5%9C%A8%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E7%9A%84%E5%BA%94%E7%94%A8/" title="Presto在各大公司的应用">Presto在各大公司的应用</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/06/bitweaving/" title="BitWeaving: Fast Scans for Main Memory Data Processing">BitWeaving: Fast Scans for Main Memory Data Processing</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/05/cache_conscious/" title="Cache Conscious Indexing for Decision-Support in Main Memory">Cache Conscious Indexing for Decision-Support in Main Memory</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/05/column_imprints/" title="Column Imprints: A Secondary Index Structure">Column Imprints: A Secondary Index Structure</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2023/05/sql_server_column_store_indexes/" title="SQL Server Column Store Indexes">SQL Server Column Store Indexes</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://code0xff.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式 (6)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">原理分析 (13)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E5%95%86%E4%B8%9A/">商业 (3)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据 (32)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库 (38)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%96%87%E5%AD%A6%E5%92%8C%E8%89%BA%E6%9C%AF/">文学和艺术 (2)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%97%85%E8%A1%8C/">旅行 (10)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%9E%B6%E6%9E%84/">架构 (2)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E7%AE%97%E6%B3%95/">算法 (8)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E7%B3%BB%E7%BB%9F/">系统 (6)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言 (3)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E8%A1%8C%E4%B8%9A%E8%A7%82%E5%AF%9F/">行业观察 (1)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 (12)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/">随便写写 (3)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">归档</a></h3>
<ul class="widget-list">
    
    <li><a href="https://code0xff.org/years/2021%E5%B9%B4/">2021年 (37)</a></li>
    
    <li><a href="https://code0xff.org/years/2022%E5%B9%B4/">2022年 (55)</a></li>
    
    <li><a href="https://code0xff.org/years/2023%E5%B9%B4/">2023年 (47)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://code0xff.org/tags/ambari/">Ambari </a>
    
    <a href="https://code0xff.org/tags/b%E6%A0%91/">B树 </a>
    
    <a href="https://code0xff.org/tags/calcite/">calcite </a>
    
    <a href="https://code0xff.org/tags/cmu-database/">CMU-Database </a>
    
    <a href="https://code0xff.org/tags/flink/">flink </a>
    
    <a href="https://code0xff.org/tags/flume/">flume </a>
    
    <a href="https://code0xff.org/tags/gc/">GC </a>
    
    <a href="https://code0xff.org/tags/gluten/">Gluten </a>
    
    <a href="https://code0xff.org/tags/hana/">HANA </a>
    
    <a href="https://code0xff.org/tags/hive/">Hive </a>
    
    <a href="https://code0xff.org/tags/k8s/">k8s </a>
    
    <a href="https://code0xff.org/tags/kudu/">kudu </a>
    
    <a href="https://code0xff.org/tags/kyuubi/">Kyuubi </a>
    
    <a href="https://code0xff.org/tags/lakehouse/">Lakehouse </a>
    
    <a href="https://code0xff.org/tags/leveldb/">LevelDB </a>
    
    <a href="https://code0xff.org/tags/llvm/">LLVM </a>
    
    <a href="https://code0xff.org/tags/manacher/">Manacher </a>
    
    <a href="https://code0xff.org/tags/mapreduce/">MapReduce </a>
    
    <a href="https://code0xff.org/tags/mysql/">MySQL </a>
    
    <a href="https://code0xff.org/tags/newsql/">NewSQL </a>
    
    <a href="https://code0xff.org/tags/oceanbase/">OceanBase </a>
    
    <a href="https://code0xff.org/tags/paxos/">paxos </a>
    
    <a href="https://code0xff.org/tags/presto/">Presto </a>
    
    <a href="https://code0xff.org/tags/quick-sql/">quick-sql </a>
    
    <a href="https://code0xff.org/tags/raft/">raft </a>
    
    <a href="https://code0xff.org/tags/scala/">scala </a>
    
    <a href="https://code0xff.org/tags/simd/">SIMD </a>
    
    <a href="https://code0xff.org/tags/snowflake/">snowflake </a>
    
    <a href="https://code0xff.org/tags/spark/">spark </a>
    
    <a href="https://code0xff.org/tags/teradata/">TeraData </a>
    
    <a href="https://code0xff.org/tags/unix/">unix </a>
    
    <a href="https://code0xff.org/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找 </a>
    
    <a href="https://code0xff.org/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">二叉树遍历 </a>
    
    <a href="https://code0xff.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式 </a>
    
    <a href="https://code0xff.org/tags/%E5%88%97%E5%AD%98/">列存 </a>
    
    <a href="https://code0xff.org/tags/%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5/">动态注入 </a>
    
    <a href="https://code0xff.org/tags/%E5%8E%86%E5%8F%B2/">历史 </a>
    
    <a href="https://code0xff.org/tags/%E5%90%91%E9%87%8F%E5%8C%96/">向量化 </a>
    
    <a href="https://code0xff.org/tags/%E5%9B%9E%E6%BA%AF/">回溯 </a>
    
    <a href="https://code0xff.org/tags/%E5%9B%BD%E5%86%85%E6%97%85%E8%A1%8C/">国内旅行 </a>
    
    <a href="https://code0xff.org/tags/%E5%9B%BD%E5%A4%96%E6%97%85%E8%A1%8C/">国外旅行 </a>
    
    <a href="https://code0xff.org/tags/%E5%A4%9A%E7%A7%9F%E6%88%B7/">多租户 </a>
    
    <a href="https://code0xff.org/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据 </a>
    
    <a href="https://code0xff.org/tags/%E5%AD%98%E5%82%A8/">存储 </a>
    
    <a href="https://code0xff.org/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/">工作记录 </a>
    
    <a href="https://code0xff.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务 </a>
    
    <a href="https://code0xff.org/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库 </a>
    
    <a href="https://code0xff.org/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/">数据模型 </a>
    
    <a href="https://code0xff.org/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/">数据迁移 </a>
    
    <a href="https://code0xff.org/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">查询优化 </a>
    
    <a href="https://code0xff.org/tags/%E6%9F%A5%E8%AF%A2%E7%BC%96%E8%AF%91/">查询编译 </a>
    
    <a href="https://code0xff.org/tags/%E6%B1%87%E7%BC%96/">汇编 </a>
    
    <a href="https://code0xff.org/tags/%E6%B5%8B%E8%AF%95/">测试 </a>
    
    <a href="https://code0xff.org/tags/%E6%B9%96%E4%BB%93%E4%B8%80%E4%BD%93/">湖仓一体 </a>
    
    <a href="https://code0xff.org/tags/%E7%94%9F%E6%B4%BB/">生活 </a>
    
    <a href="https://code0xff.org/tags/%E7%94%B5%E5%BD%B1/">电影 </a>
    
    <a href="https://code0xff.org/tags/%E7%AE%97%E6%B3%95/">算法 </a>
    
    <a href="https://code0xff.org/tags/%E7%B4%A2%E5%BC%95/">索引 </a>
    
    <a href="https://code0xff.org/tags/%E7%BB%8F%E6%B5%8E/">经济 </a>
    
    <a href="https://code0xff.org/tags/%E7%BC%93%E5%AD%98/">缓存 </a>
    
    <a href="https://code0xff.org/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理 </a>
    
    <a href="https://code0xff.org/tags/%E7%BD%91%E7%BB%9C/">网络 </a>
    
    <a href="https://code0xff.org/tags/%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/">计算框架 </a>
    
    <a href="https://code0xff.org/tags/%E8%AE%BA%E6%96%87/">论文 </a>
    
    <a href="https://code0xff.org/tags/%E8%AF%BB%E4%B9%A6/">读书 </a>
    
    <a href="https://code0xff.org/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 </a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">RSS</h3>
        <ul class="widget-list">
            <li><a href="https://code0xff.org/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div>
        &copy; 2023 <a href="https://code0xff.org/">记录每个瞬间 By 老王</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'GA ID', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>

</html>