<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>Architecture of a Database System论文翻译 | 记录每个瞬间</title>
    <meta property="og:title" content="Architecture of a Database System论文翻译 - 记录每个瞬间">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2022-09-03T11:11:11&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2022-09-03T11:11:11&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Architecture of a Database System论文翻译">
        <meta name="author" content="隔壁老王">
        
    <meta property="og:url" content="https://code0xff.cn/post/2022/09/architecture-of-a-database-system/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
        <link href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" rel="stylesheet">
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://code0xff.cn/">
                        记录每个瞬间
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://code0xff.cn/">首页</a>
                    
                    <a  href="https://code0xff.cn/linked/" title="链接">链接</a>
                    
                    <a  href="https://code0xff.cn/archives/" title="归档">归档</a>
                    
                    <a  href="https://code0xff.cn/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Architecture of a Database System论文翻译</h1>
        </header>
        <date class="post-meta meta-date">
            2022年9月3日
        </date>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction">Introduction</a>
          <ul>
            <li><a href="#relational-systems-the-life-of-a-query">Relational Systems: The Life of a Query</a></li>
          </ul>
        </li>
        <li><a href="#process-models">Process Models</a>
          <ul>
            <li><a href="#uniprocessors-and-lightweight-threads">Uniprocessors and Lightweight Threads</a></li>
            <li><a href="#dbms-threads">DBMS Threads</a></li>
            <li><a href="#standard-practice">Standard Practice</a></li>
            <li><a href="#admission-control">Admission Control</a></li>
            <li><a href="#discussion-and-additional-material">Discussion and Additional Material</a></li>
          </ul>
        </li>
        <li><a href="#parallel-architecture-processes-and-memory-coordination">Parallel Architecture: Processes and Memory Coordination</a>
          <ul>
            <li><a href="#shared-memory">Shared Memory</a></li>
            <li><a href="#shared-nothing">Shared-Nothing</a></li>
            <li><a href="#shared-disk">Shared-Disk</a></li>
            <li><a href="#numa">NUMA</a></li>
            <li><a href="#dbms-threads-and-multi-processors">DBMS Threads and Multi-processors</a></li>
            <li><a href="#standard-practice-1">Standard Practice</a></li>
            <li><a href="#discussion-and-additional-material-1">Discussion and Additional Material</a></li>
          </ul>
        </li>
        <li><a href="#relational-query-processor">Relational Query Processor</a>
          <ul>
            <li><a href="#query-parsing-and-authorization">Query Parsing and Authorization</a></li>
            <li><a href="#query-rewrite">Query Rewrite</a></li>
            <li><a href="#query-optimizer">Query Optimizer</a>
              <ul>
                <li><a href="#a-note-on-query-compilation-and-recompilation">A Note on Query Compilation and Recompilation</a></li>
              </ul>
            </li>
            <li><a href="#query-executor">Query Executor</a>
              <ul>
                <li><a href="#iterator-discussion">Iterator Discussion</a></li>
                <li><a href="#wheres-the-data">Where’s the Data?</a></li>
                <li><a href="#data-modification-statements">Data Modification Statements</a></li>
              </ul>
            </li>
            <li><a href="#access-methods">Access Methods</a></li>
            <li><a href="#data-warehouses">Data Warehouses</a>
              <ul>
                <li><a href="#bitmap-indexes">Bitmap Indexes</a></li>
                <li><a href="#fast-load">Fast Load</a></li>
                <li><a href="#materialized-views">Materialized Views</a></li>
                <li><a href="#olap-and-ad-hoc-query-support">OLAP and Ad-hoc Query Support</a></li>
                <li><a href="#optimization-of-snowflake-schema-queries">Optimization of Snowflake Schema Queries</a></li>
                <li><a href="#data-warehousing-conclusions">Data Warehousing: Conclusions</a></li>
              </ul>
            </li>
            <li><a href="#database-extensibility">Database Extensibility</a>
              <ul>
                <li><a href="#abstract-data-types">Abstract Data Types</a></li>
                <li><a href="#structured-types-and-xml">Structured Types and XML</a></li>
                <li><a href="#full-text-search">Full-Text Search</a></li>
                <li><a href="#additional-extensibility-issues">Additional Extensibility Issues</a></li>
              </ul>
            </li>
            <li><a href="#standard-practice-2">Standard Practice</a></li>
            <li><a href="#discussion-and-additional-material-2">Discussion and Additional Material</a></li>
          </ul>
        </li>
        <li><a href="#storage-management">Storage Management</a></li>
        <li><a href="#transactions-concurrency-control-and-recovery">Transactions: Concurrency Control and Recovery</a></li>
        <li><a href="#shared-components">Shared Components</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
        
        <div class="post-meta">
            
            <span class="post-meta meta-tags">
                <ul class="clearfix">
                    <a href='/categories/%E6%95%B0%E6%8D%AE%E5%BA%93'>数据库</a>
                </ul>
            </span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <blockquote>
<p>原文地址   <br>
<a href="https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf">https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf</a></p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>数据库管理系统是一个非常重要的组件，包含了学术界、工业界十多年的研究成果<br>
早期的DBMS是设计用来服务多个用户的，很多先进的理念如扩展、可靠性也被用作其他场景<br>
虽然DBMS教科书中介绍了很多算法和抽象，但关于系统设计方面的材料却很少，这篇论文就是讨论DBMS的设计理论，包括</p>
<ul>
<li>处理模型</li>
<li>并发架构</li>
<li>存储系统设计</li>
<li>事务系统实现</li>
<li>查询处理和优化架构</li>
<li>以及一些共享组件和工具</li>
</ul>
<p>数据库市场的玩家就那么几个，被高端产品占据了<br>
从事数据库的人一般都时高校、知名社区或者知名公司，范围比较小，所以影响力没那么大<br>
另外传统教科书中偏算法和抽象概念，真正到架构设计层面的很少<br>
所以这篇论文相当于是对传统教科书的补充，但不会牵涉到代码细节，毕竟太多了<br>
主要是描述DBMS系统的架构设计，再对比开源和商业数据库的设计</p>
<h3 id="relational-systems-the-life-of-a-query">Relational Systems: The Life of a Query</h3>
<p>如今的成熟的、被广泛使用的数据库系统是：关系型数据库管理系统 DBMS<br>
这些系统被用作很多应用的基础设施核心，包括：<br>
电子商务、医疗记录、账单、人力资源、工资单、客户关系管理、供应链管理<br>
DBMS作为几乎所有的在线事务、在线内容管理系统：blogs、wikis、社交网络等 <br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/1.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/1.jpg" />
        </a>
    </p>
<p>下面以一个典型的查询作为入口，来看看关系型数据库的整体结构<br>
一个登机口代理点击一个表格，请求航班的乘客列表，这个点击会触发一个单个查询事务，整个工作流程如下：</p>
<ul>
<li>客户端通讯管理
<ul>
<li>代理机构作为入口点，相当于客户端，会调用API，由DBMS的客户端通讯管理来负责</li>
<li>建立客户端&lt;-&gt;DBMS服务端的连接，比如ODBC、JDBC等，这种是两层结构</li>
<li>此外客户端可以通过一个中间件，如web服务，事务处理监听，它使用一个协议代理，作为客户端和服务端的中间层</li>
<li>上面的是三层结构，如果还有一个应用服务器，那么相当于是四层结构</li>
<li>DBMS需要兼容上面所有的场景，不过大体来说上面的连接处理都是类似的</li>
<li>建立连接，并记录连接的状态(客户端、中间件)，返回数据和控制信息(错误编码等)</li>
<li>将客户端的请求更深入的转发到DBMS中进行处理</li>
</ul>
</li>
<li>处理管理
<ul>
<li>DBMS需要分配一个计算线程，来处理上面接收到的命令</li>
<li>同时也会将计算结果通过连接返回给客户端</li>
<li>DBMS需要决定此时的查询是否要开始处理，或者延迟一段时间等待资源充足再处理</li>
</ul>
</li>
<li>查询处理
<ul>
<li>一旦开始执行，就调用查询处理模块，对用户做认证，并编译SQL查询文本，将其转换为内部的查询计划</li>
<li>计划执行器就可以执行这些计划了，计划执行程序包括一系列的算子</li>
<li>如：join，selection、projection、aggregatin、sorting等等</li>
<li>这里还包含了一个查询优化过程</li>
</ul>
</li>
<li>事务存储管理
<ul>
<li>有一个或者多个算子从数据库上请求数据，他们调用了事务存储管理模块</li>
<li>这个模块管理了所有数据的访问(读)和维护(创建、更新、删除)</li>
<li>存储系统包括用于组织和访问磁盘上数据的算法和数据结构，如表、索引</li>
<li>也包括了buffer管理，决定了数据在磁盘和内存中的移动</li>
<li>为了确保事务的ACID，需要在访问前加上lock，必须跟其他事务冲突</li>
<li>如果是更新操作，在commit时候需要持久化，如果未完成需要中止</li>
</ul>
</li>
<li>返回结果
<ul>
<li>从数据库中获取到tuple后，放到客户端的连接缓存中，返回给客户端</li>
<li>如果结果集很大，需要分批次返回，客户端下次调用还会触发到通讯管理、查询处理、存储管理模块</li>
<li>对于简单的结果就直接返回了，之后连接会关闭，事务管理会做清除状态，处理管理也会释放所有控制结构</li>
</ul>
</li>
</ul>
<p>除此之外，还有内存管理、catalog等共享组件<br>
当一个请求来了，会有认证、解析、查询优化这些阶段，都会使用到catalog <br>
DBMS也会决定内存的释放和分配</p>
<h2 id="process-models">Process Models</h2>
<p>设计多用户服务时，早期的决策需要考虑到执行多用户并发请求，以及如何将其映射到OS的进程、线程中<br>
这些设计决策深度的影响了后面的系统设计，以及性能、扩展性、移植性等<br>
我们从一个方简化的模型开始讨论<br>
讨论依赖下面的定义</p>
<ul>
<li>操作系统进程联合了操作系统程序执行单元，利用私有地址空间去执行，包括对处理器资源的管理，安全上下文，由OS内核调度单个程序执行单元，每个程序有自己唯一的地址空间</li>
<li>系统线程是一个OS程序执行单元，无需额外的私有OS上下文，无需私有地址空间，进程内的线程资源共享；线程由内核调度，系统线程称为内核线程，k-threads</li>
<li>轻量级线程，用户态线程，由用户态调度者负责调度，避免了上下文切换，比基于OS调度的更快；缺点是任何阻塞的线程都会 阻塞所有线程；可以：(1)采用异步I/O，(2)避免任何阻塞操作，轻量级线程提供了不同的模型，基于OS进程、OS线程</li>
<li>一些DBMS有自己的轻量级线程 LWT实现</li>
<li>DBMS客户端需要实现一个通讯协议跟服务端交互，如JDBC、ODBC、OLE/DB，有些是采用了嵌入式SQL编写，这种是混合了程序语言和数据库访问的技术，最初是IBM COBOL、PL/I，以及之后的SQL/J(java实现)，这个实现最终是调用API完成的，这种混合方式都是私有且无文档的</li>
<li>过去有几次尝试标准化 client-database的通讯协议，但都失败了，最著名的是 Open Group DRDA</li>
<li>工作线程用来执行客户端的请求任务，并响应，跟客户端是 1:1对应的</li>
</ul>
<h3 id="uniprocessors-and-lightweight-threads">Uniprocessors and Lightweight Threads</h3>
<p>这里我们简化了处理器模型分类，这些架构对现代的DBMS影响很大<br>
首先我们有如下假设：</p>
<ul>
<li>OS线程支持，假设OS是支持线程的，有内核线程，可以支持非常多的线程，切换开销小，内存开销也不大；这些假设在如今都是成立的，但很多DBMS最初设计时并不是这样，有些OS不支持，或者调度很差，DBMS需要自己实现</li>
<li>但处理器硬件，假设所有的设计都是在单机单CPU上，CPU包含多个核心，现代系统不会使用这种架构，但会简化讨论</li>
</ul>
<p>通过简化模型，得到了三种处理模型，如今所有的商业DBMS都使用这三种模型</p>
<ul>
<li>每个工作者一个进程</li>
<li>每个工作者一个线程</li>
<li>处理器池</li>
</ul>
<p>Process per DBMS Worker</p>
<ul>
<li>这是最简单的模型，也是最早的实现，现在仍然有商业数据库使用这种模型</li>
<li>这种模型直接将DBMS 的worker映射到OS的进程中，OS的调度器负责分配worker和DBMS的时间片</li>
<li>这种模式对于一些常见的debug工具，内存检查工具也能良好适配</li>
<li>这种模式下，DBMS的连接器，lock table、buffer pool都需要共享内存，需要OS显示的支持</li>
<li>这种模式需要大量的进程间共享内存，降低了内存地址隔离</li>
<li>这种模式需要进程间切换，包括：安全上下文、内存管理状态、文件和网络处理表、其他的进程上下文</li>
<li>这些在线程中都不需要，所以其并发效率不如线程</li>
<li>不过仍然有一些商业的数据库采用这种模型：IBM DB2、PostgreSQL、Oracle

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/2_1.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/2_1.jpg" />
        </a>
    </li>
</ul>
<p>Thread per DBMS Worker</p>
<ul>
<li>单个dispatcher线程负责分配SQL任务，然后启动对应的线程执行，执行完后线程返回，等待下一次执行</li>
<li>多线程也带来了新的挑战，其他线程导致的内存溢出会影响到当前线程，以及指针问题，调试困难，别特是条件竞争问题</li>
<li>线程接口和多线程扩展性的不同，导致软件在不同OS之间迁移很困难</li>
<li>多线程模型中的问题，在进程模型中也会存在，都是大量的使用了共享内存</li>
<li>虽然跨OS的多线程问题已经被最小化了，但仍然存在，也不好调试</li>
<li>目前使用多线程模型的包括：IBM DB2、SQLServer、MySQL、Infomix、Sybase

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/2_2.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/2_2.jpg" />
        </a>
    </li>
</ul>
<p>进程池</p>
<ul>
<li>这是进程模型的变种，有个固定大小的进程池，避免了重分配的开销</li>
<li>可以设置最大、最小进程数量，做到动态调整</li>
<li>这种模型在今天也很流行

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/2_3.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/2_3.jpg" />
        </a>
    </li>
</ul>
<p>共享数据和处理器边界</p>
<ul>
<li>所有的模型目标都是处理并发请求并尽可能独立，但实际不可能</li>
<li>他们都需要操作共享的相同的数据库，这些三种模型都需要将数据库中的数据移动到客户端</li>
<li>也就是移动到服务端进程，再将所有结果返回给客户端</li>
<li>这里主要是依靠各种buffer，主要是两种 磁盘I/O buffer，客户端通讯buffer</li>
</ul>
<p>磁盘I/O buffer</p>
<ul>
<li>最常见的跨worker的数据关系依赖，对数据库的读写操作，包括数据库请求、日志请求</li>
<li>对于线程模型，buffer pool是简单的驻留堆内存的数据结构，让所有线程共享DBMS地址空间</li>
<li>其他两种模型也是类似的，buffer pool对于进程/线程来说，都是大的共享数据结构</li>
<li>当线程需要从数据库中读一个page时，会生成一个I/O指定磁盘地址，并在buffer pool中放置一个空闲的帧</li>
<li>当需要flush buffer pool到磁盘，I/O请求包含buffer pool当前page的帧地址，并指明磁盘的目标地址</li>
</ul>
<p>日志I/O请求</p>
<ul>
<li>是一个或多个磁盘中的存储的 数组条目</li>
<li>日志在事务执行中生成，他们首先放在内存队列，然后以FIFO形式周期的flush到磁盘</li>
<li>这个队列一般叫做 log tail，一个独立的进程、线程负责周期性的将日志刷新到磁盘</li>
<li>在线程模型中，log tail是堆内存的数据结构</li>
<li>对于进程模式，有单独的进程负责管理日志，日志条目跟日志管理器通讯，是通过共享内存、或者进程间通讯交互的</li>
<li>总体来说log tail跟buffer pool的管理方式类似</li>
<li>事务必须等到日志flush到磁盘才算成功，这意味着客户端必须等到日志flush，DBMS也必须保持住所有资源</li>
<li>为了提高效率，可以批量flush一批日志</li>
</ul>
<p>以上两种都是磁盘I/O buffer，客户端通讯buffer：</p>
<ul>
<li>这是一种pull模式，客户端通过游标的方式，周期性的消费tuple</li>
<li>DBMS会在FETCH流之前工作，以便在客户端请求之间将结果排队</li>
<li>为了支持预抓取行为，DBMS用客户度通讯socket当做队列，来产生tuples</li>
<li>更复杂的方式实现，包括客户端游标缓存，DBMS客户端存储将为可能的结果，而不是依赖OS通讯缓存</li>
</ul>
<p>lock table：</p>
<ul>
<li>lock table在所有的worker中是共享的，被Lock 管理器使用</li>
<li>这是用来实现数据库的锁语义</li>
<li>共享锁表和buffer pool的技术相同，相同的技术也可以支持其他共享数据结构</li>
</ul>
<h3 id="dbms-threads">DBMS Threads</h3>
<p>前面假设OS有高性能可用的线程，DBMS只针对单个处理器 <br>
后面放宽第一个限制，多处理器和并行在后面章节讨论</p>
<p>现代的DBMS都源自1970年代的研究系统，以及1980年代的商业化努力<br>
最初DBMS构建时，都没法用到现代OS的一些特性<br>
1990年代，OS线程才被广泛的使用，即使今天，实现也有很大差异，OS线程实现也不能完全支持各种DBMS负载场景<br>
因为历史、移植性、扩展性等原因，还是有很多DMBS没有使用OS线程，他们使用的还是进程模型<br>
这样就避免了内核支持不够好导致的一些问题，一些DBMS使用了自己实现的线程模型，也就是轻量级线程<br>
每个DBMS线程管理自己的状态、通过异步、非租塞方式执行可能阻塞的I/O操作<br>
有调度线程来负责分发任务<br>
轻量级线程不是什么新概念，曾经广泛的使用于 用户态的事件驱动程序<br>
这种架构提供了快速的任务切换、方便移植，但需要将OS中的很多逻辑，在DBMS中重新实现</p>
<h3 id="standard-practice">Standard Practice</h3>
<p>我们对流行的数据库 IBM DB2、MySQL、Oracle、PostgreSQL、SQLServer做了一些总结</p>
<ul>
<li>每个进程一个worker
<ul>
<li>所有的商用数据库中，最有意思的当属 IBM DB2</li>
<li>如果OS能很好支持线程，则默认使用每worker一个线程模型，可选的是线程池模式</li>
<li>如果OS不能支持，则默认使用每worker一个进程模型，可选的是进程池模式</li>
<li>Oracle也支持进程模式</li>
<li>PostgreSQL只支持进程模型</li>
</ul>
</li>
<li>每个线程一个worker
<ul>
<li>OS线程模式：像DB2 默认就支持(如果OS对线程支持很好的话)，MySQL也是这种</li>
<li>DBMS线程，通过在OS进程、或OS线程上执行轻量级线程，调度DBMS线程</li>
<li>这种模型避免了扩展和性能问题，但代价是实现成本很高，维护成本高，相关开发工具支持较差</li>
<li>基于OS进程的轻量级线程：Sybase、Infomix使用这种模型，DBMS调度线程基于多个OS进程，以便发挥多处理器功能，这种模式不能很好做线程的load balance</li>
<li>基于OS线程的轻量级线程：SQLServer使用这种模式，在线程池上做多路复用</li>
</ul>
</li>
<li>线程/进程池
<ul>
<li>之前是进程池，后面又衍生出线程池模型，是在一个OS线程池之上做多路复用</li>
<li>基于进程池的多路复用：比进程模式更好，能支持更多连接，Oracle可选支持，通过这种方式Oracle支持超过80多种不同的OS</li>
<li>基于线程的多路复用：SQLServer默认使用这种模式，90%的SQLServer都配置了这种模式，也支持之前提到的DBMS线程模型</li>
</ul>
</li>
</ul>
<p>现代的商业DBMS，都支持内部查询并行化，也就是将单个查询的多个部分由多个处理器并行支持<br>
这需要临时分配多个DBMS工作线程/进程，来负责单个SQL查询<br>
底层的工作模型不会受这种特性的影响</p>
<h3 id="admission-control">Admission Control</h3>
<p>这章快结束时，我们来讨论下支持多并发请求，在并非场景下，吞吐量的增长可能会接近某个极限值<br>
此外，当系统快要崩溃时，它就会急速下跌，对于OS来说，崩溃场景通常是内存压力 <br>
DBMS不能将数据库的工作集的page放到buffer pool中，需要频繁的替换<br>
特别是在查询处理如：排序、join时，需要花费大量的内存<br>
在锁竞争时也会发生，事务连续的死锁，需要回滚并重启，因此任何良好的系统都需要admission control策略<br>
有了这种控制，当系统负载超标时，不接受请求直到系统可用为止，这样系统可以优雅的降级，事务延迟会成比例的增加，但仍然能保持一个峰值</p>
<p>入场控制有两个层级</p>
<ul>
<li>DBMS的dispather进程来负责管理，如果连接到达阈值后，就停止接受</li>
<li>对于不支持这种模式的DBMS，需要由其他层来负责，如应用服务器、事务处理监控、web服务等</li>
<li>第二层控制由DBMS的关系查询处理层来负责</li>
<li>在查询解析和优化之后，会决定是否需要延迟执行，只分配部分资源，以及不做任何额外的限制</li>
<li>入场控制通过半自动的信息来做决策，这些是基于请求查询的优化资源评估、以及当前可用的系统资源</li>
<li>查询优化可以指定：查询将要访问的磁盘设备、随机和顺序I/O的评估数量</li>
<li>基于查询计划算子 评估请求的CPU负载，需要处理的tuple数量</li>
<li>评估请求查收数据结构的内存占用，如排序的空间，大数据量集的hash join，以及其他查询任务</li>
<li>上面的评估往往是关键，因为很多资源抖动都是上述问题导致的</li>
<li>因此大多数DBMS，使用内存占用、活跃的工作线程作为入场控制指标</li>
</ul>
<h3 id="discussion-and-additional-material">Discussion and Additional Material</h3>
<p>处理器模型选择，在DBMS扩展、移植方面有重大影响，三个主要的商业数据库都支持多种处理模式<br>
从工程角度看，单处理器模型的移植性、扩展性都很好也很简单<br>
但是，由于使用模式的巨大差距，以及目标OS的不统一，商业数据库都支持多种模式</p>
<p>近些年，人们对新处理模型有了很大兴趣<br>
这主要是源于硬件的瓶颈、以及互联网场景的规模和可变性引起的<br>
这种设计将一个服务系统拆分为独立的多个调度 引擎，每个引擎之间都异步的传递批量消息<br>
这有点像之前提到的处理器池，工作者可以跨请求重用<br>
这种方式的创新是worker采用了一个更细粒度的任务指定风格<br>
这种调度关系是 多对多的，多个worker对应多个SQL请求，每个worker都有特定的task对于多个SQL请求<br>
这种架构有了更灵活的选择</p>
<ul>
<li>可以让单个worker有完全的task对于多个请求，可能改进整个系统的吞吐量</li>
<li>让一个请求由多个worker完成，改进了请求的延迟</li>
</ul>
<p>在一些列子中，显示了这种架构的优势，可以利用处理器的cache本地性<br>
也可以让CPU从缓存miss导致的空闲变成繁忙<br>
最近的研究项目是： StagedDB</p>
<h2 id="parallel-architecture-processes-and-memory-coordination">Parallel Architecture: Processes and Memory Coordination</h2>
<p>现代服务都是基于并行化硬件的，这章总结了各种DBMS术语，并讨论了处理器模型，每种的内存协调</p>
<h3 id="shared-memory">Shared Memory</h3>
<p>所有的处理器都访问相同的内存和磁盘，获得大致相同的性能<br>
这种架构在今天已经很标准了，大部分服务器硬件都有 2-8个处理器<br>
高端机器有十多个处理器，但性价比不高<br>
高端的并行化共享内存的机器，是硬件厂商最后的摇钱树<br>
这种一般用于大并发的在线事务处理应用，硬件花费比维护成本还低，所以购买一些小数量的、价格昂贵的系统，有时时一种权衡<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/3_1.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/3_1.jpg" />
        </a>
    </p>
<p>多核处理器支持多个进程在单个芯片上，同时也共享相同的基础设施，如共享内存架构<br>
今天所有重要的数据库都部署了多核，每个处理器都有超过一个CPU，DBMS需要完全利用这种潜能<br>
之前介绍的三种价格模式，在现代硬件上也能很好的支持<br>
对于共享内存机器的处理器模型，也是十分自然的跟随了单处理器的方式<br>
大多数数据库的演进方式，都是从单处理器架构，到共享内存架构的<br>
在共享内存架构中，OS支持透明的跨进程分配worker，所有人都可以持续的访问共享数据结构<br>
所有这三种模式在这种系统上都运行很好，支持多个、独立的SQL请求并行执行<br>
最大的挑战是修改查询执行层，使的利用并行化的能力，让单个查询跨多个CPU执行</p>
<h3 id="shared-nothing">Shared-Nothing</h3>
<p>这种架构由一组独立的机器组成，他们之前的通讯由高性能网络连接，现在也使用商业网络<br>
除了网络，一个系统没法直接访问另一个系统的内存和磁盘   <br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/3_2.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/3_2.jpg" />
        </a>
    </p>
<p>这种架构提供了一种非硬件的共享抽象，把各种机器的协调全部交给DBMS来处理<br>
最通用的方式，DBMS在每个机器/节点上，运行他们的标准处理模型，每个节点都能接受请求SQL，访问需要的元数据，编译SQL请求，执行数据访问，这些跟共享内存系统类似<br>
最主要的不同是，集群中的每个节点都存储部分数据<br>
请求会发到多个节点上，所有参与的节点都会在他们存储的数据上做查询<br>
表被分布到集群中的多个节点上，使用了水平分区的方式，这样每个节点都彼此独立的执行</p>
<p>数据库中的每个tuple被分配到独立的机器上，每个表都被水平分区到多个节点<br>
典型的数据分区为：</p>
<ul>
<li>基于tuple属性的hash的分区</li>
<li>基于tuple属性的range分区</li>
<li>round-robin</li>
<li>混合hash和range的分区</li>
</ul>
<p>每个机器负责管理本地磁盘的访问、锁、日志等<br>
查询优化器需要选择如何水平重分区这些表，跨节点的中间结果如何满足请求<br>
也分配给每个worker一个逻辑分区<br>
各个机器上的执行器，彼此发送数据请求和tuple，但是不需要传输任何线程状态和其他低级别信息<br>
这种基于数据库tuple值的分区，可以最小化协调者的需求，想要好的性能，就需要好的数据分区
这给DBA带来了很大负担，来重新智能布局表分布，查询优化器也需要做好工作负载的分区</p>
<p>这种简单的分区方式不能处理所有问题</p>
<ul>
<li>为了完成事务处理，必须显示的处理跨节点协调、提供负载均衡、支持确定的维护任务</li>
<li>处理器必须显示的交换控制信息，用来检查像分布式死锁检查、两阶段提交等问题</li>
<li>这需要额外的处理逻辑，如果处理不好会带来性能瓶颈</li>
</ul>
<p>失败的情况</p>
<ul>
<li>部分失败需要考虑的，对于内存共享系统来说，失败的处理器会导致整个机器关闭，影响整个DBMS</li>
<li>shard-nothing架构，失败的节点不会影响其他节点，但是部分数据失败还是会影响整个DBMS的行为</li>
<li>第一种，类似shard-memory架构，失败了就将所有节点关闭</li>
<li>第二种，Infomix方式，对于失败的节点，跳过这些数据，这对数据完整性要求不高，对可用性要求更高的场景</li>
<li>第二种设计并不是最好的方式，因为工作负载场景往往有多层，数据库被当做存储仓库，决定可用性vs一致性的决策往往是在高层级-应用服务器这里</li>
<li>第三种方式采用冗余机器来实现容错，细粒度的冗余如 链式分解</li>
<li>tuple的拷贝会跨节点复制，相比于简单的schema，优势为</li>
<li>需要更少的机器部署，来保证可用性</li>
<li>当一个节点挂了，剩余 n-1个节点会做原来worker的 n/(n-1) 份工作</li>
<li>当前的数据库系统采用了粗粒度和细粒度之间的冗余方式</li>
</ul>
<p>shared-nothing架构在如今非常普遍，有着非常好的伸缩性和性能成本，用于非常高端的机器，比如决策系统，数据仓库等等<br>
一般是硬件和架构的结合，这种架构通过由多个节点组成，每个节点由是shared-memory的多处理器结构</p>
<h3 id="shared-disk">Shared-Disk</h3>
<p>这种架构允许所有的处理器访问磁盘，获得大致相同的性能，但是不能访问其他节点的内存<br>
这种架构中有两个非常重要的例子</p>
<ul>
<li>Oralce RAC</li>
<li>IBM DB2 for zSeries SYSPLEX</li>
</ul>
<p>因为存储区域网络的流行，这种架构也变得流行起来<br>
SAN允许一个或多个主机挂载一个或多个逻辑磁盘，使的创建共享磁盘配置很容易</p>
<p>这种架构的优势</p>
<ul>
<li>DBA不需要数据表分区实现并行化这种情况了，管理成本降低了</li>
<li>单个节点的失败不会影响其他节点，对于shared-memory会导致全部失败，shared-noting会丢失一些数据(除非有冗余部分)</li>
</ul>
<p>缺点</p>
<ul>
<li>如果数据在达到存储系统之前，因为硬件、软件的问题导致数据损坏，那么所有的节点都会访问这些损坏数据</li>
<li>如果配置了RAID，或其他数据复制技术，则损坏的page会被冗余的复制到其他节点</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/3_3.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/3_3.jpg" />
        </a>
    </p>
<p>因为这种架构不需要关心分区问题，数据可以拷贝到RAM，并在多个分机器上修改<br>
跟共享内存架构不同，这种架构没有可以协调的共享数据位置，需要每个机器有它自己用于锁和buffer pool页的内存<br>
因此需要显示的跨多个机器的数据共享，这种架构依赖一个分布式锁管理设施，以及 用于管理分布式buffer pool缓存一致性协议<br>
这些组件很复杂，在大量竞争情况下容易出现瓶颈<br>
IBM zSeries SYSPLEX 在硬件上实现了锁管理</p>
<h3 id="numa">NUMA</h3>
<p>Non-Uniform Memory Access (NUMA) 非一致性内存访问 在独立的内存集群系统之上，提供了共享内存的程序模型<br>
每个系统都可以快速访问本地内存，也可以通过集群的高速内部连接，访问外部内部(会有些延迟)<br>
这个架构的名称来自于，内存访问时间的不一致性</p>
<p>NUMA的硬件架构是 shared-nothing 和 shared-memory 的中间地带</p>
<ul>
<li>他比shared-nothing更容易编程</li>
<li>可以比shared-memory扩展更多的处理器，它避免了共享内存总线的竞争</li>
</ul>
<p>NUMA集群被成功的应用到很多商用场景，但是NUMA没有被shared memory 多处理器采纳<br>
共享内存多处理器可以扩展到很多处理器，这种架构显示了增长的不一致性<br>
large shared memory multi-processors将其内存拆分为多份，每份都关联到一批处理器子集<br>
每份内存子集和CPU相当于一个pod，访问本地内存比远程pod内存要快<br>
NUMA的这种设计架构模式可以将共享内存系统扩展到非常多的处理器</p>
<ul>
<li>NUMA的共享内存多处理器非常通用</li>
<li>但NUMA的集群从来没有获得过什么大的市场份额</li>
</ul>
<p>DBMS访问UNMA共享内存系统的方式是，忽略非一致性内存的访问，只要非一致性较小，就可以接受<br>
当近内存：远内存的访问比例从 1.5:1 上升到 2:1 时DBMS就要考虑优化，避免内存瓶颈，优化主要是两方面</p>
<ul>
<li>当给处理器分配内存时，优先使用本地内存</li>
<li>确保worker总是跟之前的worker调度到相同的硬件处理器上</li>
</ul>
<p>使用这种方式，就可以确保DBMS在非一致性内存访问的共享内存系统上，运行良好<br>
尽管NUMA集群几乎消失了，但是程序模型、优化技术仍然被保留到当前的DBMS系统中了<br>
因为很多高可扩展共享内存系统，他们的内存访问性能都非常不一致</p>
<h3 id="dbms-threads-and-multi-processors">DBMS Threads and Multi-processors</h3>
<p>之前假设的那些问题都是单处理器的，现在这种场景下就会出现问题了<br>
之前讨论了，轻量级DBMS线程，所有的线程都运行在单个OS进程中，但是一个进程在一次只能在单个处理器上执行<br>
所以，在多处理器系统上，DBMS一次只会使用一个处理器，剩下的处理器都是空闲的，早期的Sybase SQL Server就受到这种限制<br>
随着90年代，共享内存多处理器流行，Sybase也很快修复了这个问题，使得可以利用多OS进程了</p>
<p>当DMBS线程运行在多进程中，可能会出现：某个进程要执行大量的任务，而某个进程确实空闲的<br>
为了处理这种场景，DBMS必须要实现线程在不同处理器之间迁移<br>
Informix在 6.0版本实现了这个功能</p>
<p>将DMBS的线程映射到多个OS进程中，需要决定：</p>
<ul>
<li>如何使用多个OS进程</li>
<li>如何分配DBMS线程到OS线程</li>
<li>如何跨多个OS进程分布</li>
</ul>
<p>一个最好的做法是，一个进程运行在一个物理处理器上，这样可以在硬件上最大化物理并行度，也能最小化每个进程的内存开销</p>
<h3 id="standard-practice-1">Standard Practice</h3>
<p>为了支持并行性，跟上一节的趋势类似，主要的DBMS都支持多并行模块<br>
由于共享内存系统SMP，多核系统，以及他们两者的结合体，在商业上都比较流行，主要的DBMS商场对于共享内存并行化支持的都很好了<br>
我们看到了多借点集群并行性中的区别，其中广泛的使用了shared-disk 和sharednothing架构</p>
<ul>
<li>Shared-Memory，支持的商场有IBM DB2、Oracle、SQLServer</li>
<li>Shared-Nothing，DB2、Informix、Tandem、Teradata、Greenplum提供了PG的定制版，支持Shared-Nothing</li>
<li>Shared-Disk，Oracle RAC、RDB(Oracle从DE公司收购的)、IBM DB2 for zSeries</li>
</ul>
<p>IBM 售卖多个不同的DBMS产品，并选择实现了shared disk和shared nothing支持某些场景<br>
目前位置，没有哪个厂商在同一个代码库中，同时支持shared-disk和shared-nothing<br>
微软的SQL Server这两者都不支持</p>
<h3 id="discussion-and-additional-material-1">Discussion and Additional Material</h3>
<p>上面讨论的表示，各种系统中软硬件架构模块的选择<br>
他们在DBMS领域率先使用，这些想法现在也出现在其他数据密集型领域：</p>
<ul>
<li>后端的低级别程序数据处理，map-reduce，越来越多的用户使用他们做定制化的数据分析任务</li>
</ul>
<p>即使这些新想法影响了广泛的计算领域，但 数据库系统并行设计中出现了新问题<br>
未来10年并行软件架构的关键挑战是，利用处理器厂商的新一代多核架构愿望<br>
这种设备引入了新的硬件设计点，可以在单个芯片上包含一沓子、一百，甚至上千个处理单元，处理单元之间的通讯由处理器之上的高速网络连接<br>
但是访问处理器之外的内存、磁盘仍然存在很多瓶颈<br>
结果就是，在磁盘和处理器之间的内存路径，出现了新的补平衡和瓶颈
这肯定需要重新检查DBMS架构，以满足硬件的性能潜力</p>
<p>某些相关架构正转移到可以预见的，更宏观的尺度 在面向服务计算领域 
这里，这个想法在有一万个计算机的大型数据中心，为用户提供处理(包含软件和硬件)  <br>
如果是高度自动化的，那么这种规模下的应用和服务的管理就是可以接受的<br>
非管理任务不能随着服务数量的增加而扩展，因为通常使用的是小于可靠性的商用服务器，失败会更常见<br>
所以从失败中恢复需要完全自动化<br>
在每天都有磁盘损坏，每周都有几个服务器故障的这种规模场景下，管理数据库备份通常被整个数据的在线拷贝替换，它由不同服务存储在不同磁盘上<br>
依靠数据的值，冗余的拷贝、副本甚至存储在不同的数据中心，自动的下线备份仍然被用于从应用、管理、用户错误中恢复<br>
然而，从更通用的错误和失败中恢复，快速的故障转移到冗余的在线副本，可以由多种方式实现</p>
<ul>
<li>复制在数据存储级别，SAN</li>
<li>数据复制在数据存储引擎级别</li>
<li>查询处理器 通过 冗余的查询执行</li>
<li>冗余的数据库请求自动生成在客户端软件级别，如被web服务器和应用服务器</li>
</ul>
<p>在更解耦的层次上，实践中十分通用的做法是，多个具有DBMS功能的服务被部署到不同层次中，努力最小化DBMS记录的I/O请求比列<br>
这种方案包括 用于SQL查询的各种形式的中间层数据库缓存</p>
<ul>
<li>专用的主内存数据库，如Oracle TimesTen</li>
<li>更传统的配置服务用于此目的</li>
</ul>
<p>在部署堆栈，很多面向对象的应用服务架构，支持EJB这样的编程模型，可以配置 与DBMS一致的应用对象的事务缓存<br>
然而，选择，设置，管理这些各种方案仍然是非标准的而且是复制的，这种优雅统一、一致性的模型，仍然难以捉摸</p>
<h2 id="relational-query-processor">Relational Query Processor</h2>
<p>前面的章节关注于DBMS的宏观设计，现在开始要调整方向了，关注于一系列的细粒度部分，处理每个DBMS的主要组件<br>
现在开始讨论查询处理部分，然后是存储管理，事务，通用工具<br>
一个关系查询处理器 接受一个申明式SQL语句，校验它、优化它，变为一个程序数据流执行计划(子主题为准入控制)，之后代表客户端执行数据流程序<br>
客户端之后获取tuples结果，通过一次一个或小批次<br>
关系查询处理器的主要组件展示在 图1.1中，本章节中主要关系查询处理器、存储访问模式的非事务部分<br>
关系查询处理可以当做一个单用户、单线程的任务，并发控制透明的由底层系统支持
这个规则的例外是，DBMS必须显示的pin和unpin buffer pool的page，同时对他们操作，以便他们简短的、关键的操作时驻留在内存中</p>
<p>本节中，我们主要焦点在通用的SQL命令</p>
<ul>
<li>数据管理语言DML声明，SELECT、INSERT、UPDATE、DELETE</li>
<li>数据定义语言DDL声明，CREATE TABLE、CREATA INDEX，没有被查询优化处理</li>
</ul>
<p>这些声明通常在静态DBMS逻辑中通过显示调用 存储引擎、目录管理器 程序化实现的<br>
一些产品开始在小范围的DDL申明上做优化，我们预计这种趋势会继续下去</p>
<h3 id="query-parsing-and-authorization">Query Parsing and Authorization</h3>
<p>对于给定的SQL申明，SQL解析的主要任务</p>
<ul>
<li>检查这个查询是正确的指定</li>
<li>解释名字和引用</li>
<li>通过优化器，将查询转换到内部格式</li>
<li>校验用户是否有查询权限</li>
</ul>
<p>有些DBMS会推迟一些、或所有的安全检查到执行时再执行 <br>
解析器仍然有责任，收集执行时安全检查所需的数据</p>
<p>对于给定的SQL，解析器首先考虑每个表在FROM句子中的引用</p>
<ul>
<li>对表名做规范化处理</li>
<li>变成 四部分</li>
<li>server.database.schema.table</li>
<li>对于查询不支持跨多个系统的，规范化的名字可以限定为：database.schema.table</li>
<li>对于每个DBMS只支持一个数据库的，规范化名字可以限定为： schema.table</li>
<li>这个限定是必须的，用户可以使用上下文环境的默认值，这样后面只需要填写 table名字就可以了</li>
<li>有些系统对于一个表有多个名字，如别名，这种的也需要做 全限定表名</li>
</ul>
<p>在规范化表名之后，查询处理器会调用 catalog-manager，在这个阶段中，系统会在内部查询数据结构中，缓存表的元数据<br>
基于表的信息，使用catalog来确保属性引用的正确性，属性的数据类型被使用来消除重载表达式的不确定性的逻辑，比较算子，常量表达式<br>
比如：</p>
<ul>
<li>(EMP.salary * 1.15) &lt; 75000</li>
</ul>
<p>这里有乘法函数和比较算子，假设数据类型和string的内部格式 1.15，75000，这需要依赖EMP.salary的数据类型<br>
这个类型可能是 integer、float、money<br>
额外的标准SQL语法检查也被应用</p>
<ul>
<li>包括tuple变量的一致性使用</li>
<li>通过集合算子 UNION/INTERSECT/EXCEPT 组合的表的兼容性</li>
<li>在聚合查询SELECT 列表中使用属性</li>
<li>内嵌的子查询等等</li>
</ul>
<p>如果查询解析成功，下一个阶段就是认证，确保用户有合适的权限 SELECT/DELETE/INSERT/UPDATE 在这个表上，用户定义函数、或者其他在查询中的对象引用等<br>
一些系统在申明解析阶段执行完全的认证检查，并不总是这样<br>
系统支持行级别的安全，比如 直到执行期间才能做完全的安全检查，因为安全检查依赖数据类型<br>
即使理论上可以在编译期间做静态校验，但推迟这个执行到查询执行期间会更有优势<br>
推迟安全检查到执行期间的查询计划，可以在用户之间共享，并且当安全改变时不需要重新编译<br>
基于这个结论，部分安全校验通常推迟到查询计划执行时<br>
同样在编译期间，也可能约束检查常量表达式，比如一个UPDATE有一个子句</p>
<ul>
<li>SET EMP.salary = -1</li>
</ul>
<p>如果对salary做了整型约束指定正数值的限定，那么查询甚至不需要被执行<br>
将这个工作推迟到执行期间是非常常见的<br>
如果查询解析并传递校验，之后查询的内部格式 传递给查询重写模块做进一步处理</p>
<h3 id="query-rewrite">Query Rewrite</h3>
<p>这个模块有责任简化、规范化查询而不需要改变其语义，它依赖查询和catalog的元数据，不需要访问表中的数据<br>
尽管叫重写查询，但实际上是操作查询的内部表示，而不是操作原始的SQL声明文本<br>
查询重写模块各通常产生一个 相同内部格式(来自输入数据)的查询内部表示<br>
重写在很多商业系统中是一个逻辑组件，真实的实现</p>
<ul>
<li>查询解析的后期阶段</li>
<li>查询优化的早起阶段</li>
</ul>
<p>比如DB2，查询重写是一个方独立的组件，而SQLSserver中查询重写是 查询优化的早起阶段<br>
尽管如此，单独考虑查询重写仍然是有用的，即使显示的架构边界不存在任何系统中<br>
查询重写的主要责任</p>
<ul>
<li>view expansion
<ul>
<li>视图重写是主要的传统角色，对于每个出现在FROM中的视图引用，重写器从catalog中找出视图的定义</li>
<li>重写视图，用表和谓词引用替换视图</li>
<li>替换任何对视图列的引用，到表的引用</li>
<li>处理使用递归的方式执行，直到表达式中仅包含表或者没有视图</li>
<li>视图展开技术，在基于QUEL语言的INGRES中被提出，需要在SQL中处理去重，内嵌查询，NULL和其他麻烦细节</li>
</ul>
</li>
<li>constant arithmetic evaluation
<ul>
<li>查询重写可以简化常量算数表达式</li>
<li>R。x &lt; 10 + 2 +R.y 被重写为 R.X &lt; 12 + R.y</li>
</ul>
</li>
<li>logical rewriting of predicates
<ul>
<li>应用基于WHERE子句中的谓词和常量</li>
<li>简单的bool逻辑通常应用在 表达式 和 基于索引访问模式之间的匹配</li>
<li>一个谓词如 NOT EMP.salary &gt; 1000 可以重写为 EMP.salary &lt;= 1000</li>
<li>逻辑重写甚至可以短路查询执行，如: EMP.salary &lt; 7500 AND EMP.salary &gt; 10000</li>
<li>这种的就直接返回FLASE，系统会返回空的查询结果而不需要访问数据库</li>
<li>谓词可能会隐藏在视图定义中，而外部使用的人并不知道</li>
<li>对于上述例子，结果可能来自叫：Executives视图的低薪水员工</li>
<li>SQLServer在并行化查询中，如果某些谓词不满足，则可以过滤掉一些分区</li>
<li>当一个关系是通过range谓词，水平分区跨多个磁盘的，如果range分区谓词不满足查询谓词连接，则无需此磁盘上运行</li>
<li>重写谓词传递性，来引导另一个谓词, R.x &lt; 10 AND R.x = S.y，建议添加额外的谓词 AND S.y &lt; 10</li>
<li>添加传递性谓词，可以增加优化器在选择早期 过滤数据的计划能力。特别是基于索引的访问模式</li>
</ul>
</li>
<li>semantic optimization
<ul>
<li>schema的完整性约束一般是存储在catalog中，可以用来帮助重写一些查询，比如 消除冗余的join</li>
<li>比如一个外检约束绑定到 EMP.deptno 表的一个列上</li>
<li>通过这个外键约束，可以确切的知道，一个Dept对应每个EMP，并且在没有对应的Dept tuple情况下，不存在EMP的tuple</li>
<li>有这样的SQL: SELECT emp.name, emp.salary FROM emp, dept WHERE emp.deptno = dept.dno</li>
<li>如果emp.deptno 被约束为非null，则可以移除掉 dept这个表</li>
<li>这种场景一般在视图中出现，可以提交一个员工查询的请求，它是基于empdept这个视图的，底层join了这两个表</li>
<li>Siebel使用非常宽的表，如果底层数据库不支持足够宽的表，那么使用带有视图的多个表</li>
<li>在没有冗余join消除时，这种基于视图的宽表实现，性能会很差</li>
<li>当表上的约束和查询谓词不兼容时，语义优化可以 回避整个查询执行</li>
</ul>
</li>
<li>subquery flattening and other heuristic rewrites
<ul>
<li>查询优化是当代商业数据库最复杂的组件之一</li>
<li>为维持这种复杂性，优化器通用操作独立的 SELECT-FROM-WHERE查询块，而不会跨块操作</li>
<li>很多系统重写查询到一个更合适优化的形态，而不是继续复制的查询优化</li>
<li>这类转换通常是规范化，通常是重写语义等价的查询到一个规范化形态，语义等价查询会被优化到相同的查询计划</li>
<li>另一个重要的启发式扁平化内嵌查询，以最大化为查询优化器的单快优化提供机会</li>
<li>这种类型的SQL很棘手，比如重复的语义，子查询，NULL</li>
<li>早期子查询展开是纯粹的启发式重写，不过现在的产品用基于代价分析的方式决定重写</li>
<li>其他的重写可能会跨查询块，如谓词传递，允许谓词被跨子查询拷贝</li>
<li>展开关联子查询是非常重要，在并行架构中可以实现很好的性能</li>
<li>关联子查询结果在 跨查询块的 nested-loop比较风格中，它序列化子查询执行，尽管有并行资源可以</li>
</ul>
</li>
</ul>
<h3 id="query-optimizer">Query Optimizer</h3>
<p>查询优化器的任务是转换一个内部的查询表示，到一个高效的查询计划，提供给查询执行<br>
一个查询计划可以认为是一个数据流图，通过查询算子的图来传递表数据<br>

        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/4_1.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/4_1.jpg" />
        </a>
    </p>
<p>大多数系统首先将查询分解为：SELECT-FROM-WHERE 查询快<br>
每个独立的查询快优化 使用已有的技术做优化，这个技术来自于System R优化器，这是1979年的一篇著名论文：《Access
path selection in a relational database management system》<br>
在完成时，一些算子通常被增加到每个查询块的顶部，以为后续的计算GROUP BY、ORDER BY、HAVING、DISTINCT子句(如果他们存在的话)，各种块用简单的方式缝合在一起</p>
<p>可以有多种方式表示查询计划</p>
<ul>
<li>原始的System R编译查询计划到机器代码</li>
<li>早期的INGRES生成一个可解释的查询计划</li>
</ul>
<p>查询解释被当做一个错误，1980年早期的INGRES作者在他们的论文中报告
摩尔定律和软件工程证明了INGRES的正确性 <br>
讽刺的是，编译成机器代码被System R的一些研究人员认为是错误的；当System R的代码变成商业化DBMS后，开发团建首先用解释器替换了 机器代码执行</p>
<p>为了支持跨平台迁移能力，每个主要的DBMS现在编译他们的查询到各种可翻译类型的数据结构，他们之间唯一的却别是中间形式的抽象级别<br>
查询计划在一些系统总非常轻量，不像关系代数表达式那样，它用访问方式的名称、join算法等对名称做了注释<br>
其他一些系统使用了低级别语言 op-code，有点类似于 Java的字节码，而不是关系代码表达式<br>
为了简化我们的讨论，在后续论文的后续部分，将重点讨论类似代数查询的表示</p>
<p>《Access path selection in a relational database management system》这篇论文被认为是查询优化领域的圣经，不过这篇论文只是初步研究<br>
所有的系统都显著扩展了这项工作，主要包括这几个扩展：</p>
<ul>
<li>Plan space
<ul>
<li>早期的System R限制了查询空间，强制使用了 left-deep查询计划</li>
<li>join中输入的右边必须当做基表</li>
<li>笛卡尔积会被推迟，直到所有的数据流join之后才会出现</li>
<li>现代的系统，使用茂密树bushy trees，内嵌的右输入</li>
<li>早期的笛卡尔积在某些情况下是有用的</li>
<li>因此大多数系统，只是某些情况下才会考虑这两种选择</li>
</ul>
</li>
<li>Selectivity estimation
<ul>
<li>在论文中，选择性评估计算，只基于简单表和索引基础，符合当前生成的标准</li>
<li>现代系统分析、总结属性中的值分布，通过直方图和其他汇总信息</li>
<li>因为牵涉到访问每个列中的每个值，代价可能很高</li>
<li>所以现代的系统很多实用了采用技术，获取分布的评估，而不需要代价啊很高的详细扫描</li>
<li>通过选择join列上的柱状图，来选择性的评估基于表的join</li>
<li>为了支持超过一个列，最近有学者提出了更复杂的方案，类似列之间的依赖性等问题</li>
<li>这些方案被缓慢采用的原因是，很多工业界的基准测试中都存在长期的缺陷</li>
<li>基准测试(TPC-D、TPC-H)的数据生成器，在列上生成了独立的统计值，因为不鼓励采用新技术处理真实数据分布</li>
<li>基准测试中的这些问题在TPC-DS中已经处理了</li>
<li>尽管采用率较低，但改进的选择性评估的好处被广泛认可</li>
<li>有学者注意到，在优化早期，选择性的错误沿着计划树的乘法式传播，导致可怕的后续评估</li>
</ul>
</li>
<li>Search Algorithms
<ul>
<li>一些商用系统如微软、Tandem，放弃了动态规划方式，采用了目标导向，使用级联中基于 自顶向下的查找模式</li>
<li>top-down的优化方式可以减少查询计划的数量，但是这种方式会增加内存开销</li>
<li>如果实际的成功是质量指标，那么选择top-down或者DP都是无关紧要的</li>
<li>他们两在最近的优化器中都能很好工作，但是表数量一旦增加，运行时间和内存需求都呈指数增加</li>
<li>当有太多表时，退化到启发式搜索，商用的的启发式搜索都是专有的，跟随机化查询优化文献中并不相同</li>
<li>一个有意义的试验是检查开源的MySQL，它的最后检查完全是启发式的，主要利用索引和外键约束(早期的Oracle也是这样)</li>
<li>在某些系统中，如果FROM子句中有太多的表，只有用户显示指定优化器如何选择一个计划(hints提示)，这个语句才能执行</li>
</ul>
</li>
<li>Parallelism
<ul>
<li>intra query，将单个查询在多个处理器上执行</li>
<li>这种方式就需要考虑如何调度算子，如果将某些算子并行化，并利用多核的能力</li>
<li>为了避免调度的复杂性，Stonebraker等人将其分为两个阶段调度</li>
<li>首先用传统的单系统优化器，找到最佳的单系统执行计划；然后跨多个系统调度该执行计划</li>
<li>有些系统尝试对集群的网络拓扑、数据分布建模，然后产生一个但阶段的执行计划</li>
<li>使用单个查询优化带来的复杂性，是否跟优化后的能力相匹配不得而知</li>
<li>Oracle的RAC使用两阶段，DB2是最早使用两阶段的，后来目标是一阶段</li>
<li>论文：《Optimization of parallel query execution plansin xprs》</li>
</ul>
</li>
<li>Auto-Tuning
<ul>
<li>这是工业界的努力方向，通过收集数据来让DBMS实现自动调优</li>
<li>优化器会做各种假设分析，比如使用其他索引会怎样，改变数据布局会怎样？</li>
<li>需要对优化器做一些调整，才能支持此活动</li>
</ul>
</li>
</ul>
<h4 id="a-note-on-query-compilation-and-recompilation">A Note on Query Compilation and Recompilation</h4>
<p>SQL支持查询准备，将其传递给解析器、重写器、优化器，并存储查询执行计划，用于后续的执行声明<br>
可以支持动态查询，如web表单传递过来的，只是对于选择性评估有点弱<br>
提供的表单由优化器假定可以接受典型的值<br>
当非表示的典型值被选择后，会出现非常糟糕的查询执行计划<br>
查询准备对于表格驱动的数据非常有用，可以公平的预测数据：当应用编写的时候，查询就开始准备了<br>
当应用开启时，就不需要体验额外的解析、重写、优化开销</p>
<p>查询准备可以提升性能，但是受应用程序模型限制，很多应用程序使用类似Ruby on Rails这样的工具 <br>
在程序执行期间，动态的建立SQL，所以预编译不是可选项，因为太常见了<br>
DBMS将查询计划缓存，后续如果发现有相同、或者非常类似的提交，就使用缓存中的查询计划<br>
这个技术类似于执行一个静态SQL预编译，但是没有应用模型限制，可以被大量使用</p>
<p>随着时间推移，数据库可能发生改变，比如索引被删除了，那么对应的查询计划就需要改变<br>
新的查询计划需要更新到缓存中以便下一次可以使用<br>
这里出现了两种不同的设计方式</p>
<ul>
<li>IBM非常努力的在多个调用之间预测执行能力，以牺牲每次调用执行时间为代价，所以不需要再优化</li>
<li>SQLServer则是努力让他们的系统能自动调优，以便能更新优化器，比如表的基数变了，就会触发重编译，因为这会影响索引的选择、join的顺序</li>
</ul>
<p>这种设计上的差异是市场策略导致的</p>
<ul>
<li>IBM的客户当时都是高端的，有高端DBA和编码能力，一般会自己调优很长时间，所以不需要DBMS再改变优化器</li>
<li>SqlServer则是低端客户，希望DBMS能自动调优</li>
</ul>
<p>但随时间推移，双方的市场策略都会有重合，IBM也出现自动化调优<br>
SQLServer也有高端用户了</p>
<h3 id="query-executor">Query Executor</h3>
<p>查询执行是操作一个已经完全定义好的查询计划<br>
查询计划一般是一个链接了各种算子的数据流图，而算子是对表访问、查询执行算法的封装<br>
某些系统中数据流图是直接编译到低级别的op-code中了(优化器编译的)<br>
在本例中，查询执行是基于一个运行时的解释器<br>
在有些系统中，查询执行器接受一个数据流图的表示，然后产生基于图布局的算子
我们主要讨论后者，op-code的方式本质上市将我们讨论的逻辑编译到一个程序中</p>
<p>大部分现代查询执行器使用 迭代模型，这也是最早的关系型数据库中使用<br>
迭代模型在面向对象风格中可以简单表示 ，下面就是一个迭代模型的伪代码</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">iterator</span> {
    iterator <span style="color:#ff79c6">&amp;</span>inputs[];
    <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">init</span>();
    tuple <span style="color:#50fa7b">get_next</span>();
    <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">close</span>();
} 
</code></pre></td></tr></table>
</div>
</div><p>Iterator superclass pseudocode.</p>
<p>每个算子都定义了一个输入，也就是数据流图中的边的定义<br>
一个查询计划中的所有算子，数据流图中的节点，可以作为迭代器类的自类来实现<br>
这一系列的子类，一般包括：</p>
<ul>
<li>filescan</li>
<li>indexscan</li>
<li>sort</li>
<li>nested-loops join</li>
<li>merge-join</li>
<li>hashjoin</li>
<li>duplicate-elimination</li>
<li>grouped-aggregation</li>
</ul>
<p>迭代器模式有一个重要的特点：任何一个迭代器的子类可以当做另一个的输入<br>
因此迭代器的逻辑跟其父节点、子节点都是独立的，也不需要为特殊的case做适配<br>
PostgreSQL为大多数标准查询执行算法，使用了适当复杂度的迭代器实现<br>
相关论文：《Query evaluation techniques for large databases》</p>
<h4 id="iterator-discussion">Iterator Discussion</h4>
<p>迭代模型有一个重要的特点，数据流、控制流是耦合的<br>
<code>get_next()</code>是一个标准的程序调用，通过调用栈，将返回的tuple引用给调用者<br>
所以，当控制返回时，一个tuple会确切的返回给它的父节点，这也暗示了DBMS中只有单个线程来执行整个查询，多个查询、或者迭代器之间的速率匹配则不需要<br>
这个好处是关系查询的实现逻辑很清晰，也很容易debug<br>
相比其他的数据流架构，比如网络中，依赖各种协议在并发的生产者和消费者之间排队和反馈</p>
<p>迭代模型在单系统，也就是非集群模式下是很有效的，对于大多数应用来说，优秀的指标包括</p>
<ul>
<li>查询完成的时间</li>
<li>其他也包括：DBMS的最大吞吐量</li>
<li>交互式应用中：第一行的返回时间</li>
</ul>
<p>对于单个处理器环境中，给定的查询完成时间，是在资源得到完全利用时实现的<br>
在迭代模式中，迭代器总是活跃的，所以资源利用率是最大化的</p>
<p>现代DBMS支持并行化，在迭代模型、查询架构不需要太大改动的情况下，是可以执行并行化的<br>
并行化、网络通讯可以被封装到一个特殊的 exchange 迭代器中，相关论文：<br>
《Encapsulation of parallelism in the volcano query processing system》<br>
这篇论文中，实现了网络风格的 push 迭代器，它对于DBMS迭代器是不可见的，当然也保留了 pull 风格的 get_next()<br>
有些系统也可以显示的在他们的系统中实现 push 逻辑</p>
<h4 id="wheres-the-data">Where’s the Data?</h4>
<p>迭代模式可以规避动态内存分配问题，不需要指定内存中有多少tuple，也不需要迭代器之间传递多少tuple<br>
实际上，每个迭代器都预先分配了一个固定大小的 tuple 描述符，一个用于输入，一个用于输出<br>
tuple 描述符通常是一个 列引用数组，每个列引用下面组成：</p>
<ul>
<li>引用到内存中其他地方的tuple</li>
<li>引用的那个tuple的偏移量</li>
</ul>
<p>迭代器模式的超类也不会动态分配内存，那么问题是，实际被引用的 tuple 是存储在哪里的？<br>
有两种可能<br>
1、tuple是驻留在buffer pool的 pages中的，也叫做 BP tuple<br>
一个迭代器构建了tuple描述符，那么就会引用到BP tuple<br>
在引用期间，必须要增加 pin 的数量，它 钉住的是 page上正在被引用的tuple，当tuple 描述符清空时，pin 数量也就减少</p>
<p>2、迭代器实现可能在 内存堆上为tuple 分配空间，这叫：M-tuple</p>
<ul>
<li>迭代器可以通过从buffer pool拷贝列，来创建M-tuple，通过引脚递增/递减 来拷贝副本</li>
<li>通过查询规范中的评估表达式，如EMP.sal * 0.1</li>
<li>一个通用的方式是，立即从buffer pool中拷贝出数据，到M-tuple中</li>
<li>这种设计将M-tuple当做动态tuple结构，并可以简化执行器的代码</li>
<li>可以规避掉bug，这些bug是从隔离的buffer pool pin和unpin中返回的，他们是被程序长期周期执行的</li>
<li>一个通用的bug可能就是忘记unpin了，内存泄露</li>
<li>独占的M-tuple是一个主要的性能问题，因为频繁的拷贝，对于高性能系统是一个严重瓶颈</li>
</ul>
<p>另一方面，构造一个 M-tuple在某些场景下会有用<br>
只要BP-tuple直接被迭代器引用，那么BP-tuple上的page必须保留pin，这会消耗掉bufer pool内存的一个page，也限制了buffer的替换策略<br>
如果tuple在很长一段周期内被持续引用，那么从buffer pool中拷贝tuple也是有益的</p>
<p>讨论的结果是，最有效的方式支持 tuple描述符，是可以引用</p>
<ul>
<li>BP-tuples</li>
<li>M-tuples</li>
</ul>
<h4 id="data-modification-statements">Data Modification Statements</h4>
<p>目前为止，只讨论了查询，这些都是只读的，对于 DML 来说，还有 insert、update、delete<br>
这些语句的执行计划看起来都比较简单，类似一条直线<br>
使用单一访问方法作为源，修改申明一般在pipeline都末尾</p>
<p>对于包含了读和更改的查询，他们公用一份数据需要特别小心，比如 IBM System R 发现的万圣节问题<br>
给每个低于 2W美元的人加10%薪水 <br>
如下，索引的scan迭代器扫描 Emp.salary 后交给更新的迭代器，由于tuple是从B树中获得的，因此性能很不错<br>
这里会出现一些问题</p>
<ul>
<li>这种pipeline的方式，可能会导致 索引扫描 <strong>重新发现</strong>之前被修改过的tuple，这些之前被修改过的tuple是往右移动的</li>
<li>这样会导致每个员工都被多次加薪</li>
<li>在这个例子中，这些员工会一直加薪直到他们的薪水超过了 2W</li>
</ul>
<p>查询的SQL:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#ff79c6">UPDATE</span> EMP
 <span style="color:#ff79c6">SET</span> salary<span style="color:#ff79c6">=</span>salary<span style="color:#ff79c6">*</span><span style="color:#bd93f9">1</span>.<span style="color:#bd93f9">1</span>
 <span style="color:#ff79c6">WHERE</span> salary <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">20000</span>
</code></pre></td></tr></table>
</div>
</div><p>
        <a data-fancybox="gallery" href="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/4_3.jpg">
            <img class="mx-auto" alt="" src="https://woquhaha.gitee.io/pic_tech_1/post/2022/09/A%20Relational%20Model%20of%20Data%20for%20Large%20Shared%20Data%20Banks/4_3.jpg" />
        </a>
    <br>
Fig. 4.3 Two query plans for updating a table via an IndexScan. The plan on the left is susceptible to the Halloween problem. The plan on the right is safe, since it identifies all tuples to be updated before actually performing any updates.</p>
<p>SQL语义禁止的行为：单个SQL不允许 看到 他自己的更新，需要确保这个可见性的规则<br>
一个简单安全的实现是，查询优化器避免在更新列上建立 查询计划，但这回导致非常低效的查询</p>
<p>另一种实现方式是：批量的读和写</p>
<ul>
<li>他是在数据流中的 索引扫描 和 数据修改操作之间，插入Record-ID物化和抓取这样的动作</li>
<li>物化操作是将所有被修改的tuple ID存储到临时文件中</li>
<li>之后扫描临时文件，通过RID获取每个物理tuple ID，再将结果交给修改算子</li>
<li>如果优化器选择索引，那么大多数情况下智慧更新少数一些tuple</li>
<li>这种实现看起来会很低效，因为要写到临时文件中，但可以将所有待修改的tuple全部放到buffer pool中</li>
</ul>
<p>pipeline更新的方式也是可能的，但需要存储引擎的多版本支持(有点奇怪)</p>
<h3 id="access-methods">Access Methods</h3>
<p>访问方式：管理访问各种基于磁盘数据结构的方式，通常包括</p>
<ul>
<li>未排序的文件，heap</li>
<li>各种类型的索引</li>
</ul>
<p>所有主要的商业系统都实现了 heap 和B+树索引，Oracle和PG支持hash索引和等价的查找<br>
有些系统开始引入还不太成熟的 多维索引，比如 R树<br>
PG支持扩展索引：通用查找树 GiST，当前使用 R树来支持多维索引，用 RD树 支持文本数据<br>
IBM引用多维聚集索引 MDC 来支持多维上的范围访问<br>
以读为目标的 数据仓库，使用索引的变种 bitmap</p>
<p>基础API，访问方法提供基本的迭代API，init()被扩展为接受单表列算子常数的搜索参数(System R术语SAGR)<br>
NULL SARG用来扫描所有的tuple，当没有tuple满足搜索参数时， get_next()返访问模式层返回 NULL<br>
有两个原因需要传递 SARG 到访问方式层</p>
<ul>
<li>索引方式类似B+树，可以提供有效性能</li>
<li>一个不易察觉的性能问题，它适用于 heap扫描，也适用于索引扫描</li>
</ul>
<p>假设 SARG 由访问方法层来做检查，那么每次访问方式从 get_next()返回都需要(二选一)</p>
<ul>
<li>返回一个驻留在buffer pool帧中的句柄，并且钉住这帧中的page，避免替换</li>
<li>创建tuple的拷贝</li>
</ul>
<p>如果调用查找 SARG没有满足，那么(二选一)</p>
<ul>
<li>减少page上的pin</li>
<li>删除tuple的拷贝</li>
</ul>
<p>同时继续调用 get_next() 尝试获取下一次tuple，这种逻辑在调用/返回时，会消耗大量的CPU</p>
<ul>
<li>不必要的在buffer pool中钉住page，会产生不必要的buffer 帧的竞争</li>
<li>创建不必要的tuple拷贝</li>
</ul>
<p>在有几百万tuple传输时，会有大量的CPU负载<br>
heap 扫描会访问给定page上的所有tuple，对于每个page会有交互式的多次迭代<br>
如果所有的逻辑都在访问方式层中完成，那么重复的调用/返回 对和 pin/unpin或者copy/delete都可以被SARG在一次一个page中避免<br>
对于满足SARG的tuple，都可以只从get_next()调用中返回<br>
SARG这种架构很清晰，保持了存储引擎 和 关系引擎的边界，有着很好的性能<br>
很多系统都对SARG有支持，这种主要是应用了CPU性能，而不是磁盘性能</p>
<p>所有的DBMS需要一种方式指向基表中的行，以便索引条目可以引用这些行<br>
在很多DBMS中，这种实现是使用 rows ID做的，也就是基表中行的 物理磁盘地址</p>
<ul>
<li>这种方式的好处是，查询很快</li>
<li>缺点是，基表中的行移动开销很大，因为所有的二级索引都需要更新</li>
</ul>
<p>更新和查询的行都有代价</p>
<ul>
<li>当一个更新改变了行的size，刚刚更新的page上也没有可用空间了</li>
<li>当 B+ 树分裂时，很多行需要移动</li>
</ul>
<p>DB2使用 forwarding指针来避免第一个问题，不过这需要第二次I/O来发现需要移动的页，但是避免了二级索引的更新<br>
对于第二个问题，DB2不支持基表tuple用 B+树作为主存储，SQLServer和Oracle支持B+树作为主存储，并且能高效处理row的移动<br>
这种方式避免在 二级索引中使用物理行地址作为，而使用 主键key，如果没有唯一key则使用内置唯一key<br>
当使用二级索引访问基表时，会有性能损失，但是避免了行移动的问题<br>
Oracle通过保持一个主键的物理指针，来避免这些性能问题：如果行没有移动，则使用物理主键指针，这样可以快速找到数据；否则行移动了，使用较慢的主键技术</p>
<p>Oracle避免移动heap文件中的行，允许行跨page<br>
当行更新一个很大的值，同时原page也没有足够空间时，不再强制移动行，而是：<br>
将合适的空间存储在原始page，而剩下的数据可以跨page存储<br>
相比于其他迭代器，访问方式跟并发控制，恢复逻辑有深度的交互</p>
<h3 id="data-warehouses">Data Warehouses</h3>
<p>数据仓库：对于决策分析支持的 海量历史数据库，周期性的加载新的数据<br>
现在已经发展到需要专门的查询技术来支持，这个话题之所以相关，有两个原因</p>
<ul>
<li>数据仓库是DBMS中非常重要的应用技术，据说占据了DBMS活动的 1/3</li>
<li>当前的查询优化，执行引擎，都不能很好的在数据仓库中工作，所以需要一些修改来实现更好的性能</li>
</ul>
<p>1970年第一个关系型数据库架构出现<br>
1980年代出现了很多商业数据处理应用的需求，这在当时是主要需求<br>
1990年代，数据仓库，商业分析出现，并且快速增长<br>
1990年代 OLTP已经替代了批量商业数据处理，称为数据库的主要范式<br>
但是大多数OLTP需要银行操作员提交事务</p>
<ul>
<li>终端客户的电话会话</li>
<li>从打印纸上执行数据条目</li>
</ul>
<p>于是自动执行这些任务就变成迫切的了，允许客户端支持和机器交互，而不需要操作员 <br>
响应时间变得非常重要，称为重要生产力，尤其像web也因为快速发展，终端客户更需要自动化处理</p>
<p>与此同时，企业像捕获销售数据，将其存储 1-2年<br>
这是历史数据可以发现，购买者想要什么，以及不想要什么，这些信息也可以利用影响采购模式<br>
这些数据可以促进决策提升，哪些需要打折的，哪些是需要返厂的<br>
当时普遍的看法是，历史数据仓库可以通过改善存储管理、货架、以及存储布局，可以几个月左右回收成本</p>
<p>数据仓库应该被部署到跟 OLTP独立的硬件中，按照这种方法论<br>
商业智能的查询不会干扰到 OLTP响应时间，同样他们的数据页非常不同<br>
数据仓库处理的是历史数据，OLTP处理的是现在的数据<br>
最终会发现，对于历史数据期望的模式，跟当前数据所需的模式不匹配，需要将数据从一处转移到另一处</p>
<p>处于这样的原因，需要对OLTP的数据做抓取，加载到数据仓库中，于是出现了 ETL这种系统<br>
流行的ETL包括 data stage IBM的， PowerCenter Informatica的<br>
ETL厂商还扩展了他们的ETL产品，比如去重工具，面向质量的交付等<br>
数据仓库环境需要解决一些问题需要处理，我们接下来讨论</p>
<h4 id="bitmap-indexes">Bitmap Indexes</h4>
<p>B+树 是被优化作为快速insert、delete、update使用的，而数据仓库做了数据初始化之后，可能很长时间都不会更新<br>
另外，数据仓库的某些列可能只包含很小的值，比如客户的性别，这里只有两个值<br>
这种情况可以用<code>bitmap</code>来表示，只需要一个bit就可以了<br>
相反，如果用B+树， 每个记录都需要(value,记录指针)，这样每个记录会消耗掉40bit<br>
bitmap还对于联合的filter条件也有利：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">Customer.sex <span style="color:#ff79c6">=</span> “F” <span style="color:#ff79c6">and</span> Customer.<span style="color:#ff79c6">state</span> <span style="color:#ff79c6">=</span> “California”
</code></pre></td></tr></table>
</div>
</div><p>这个结果由相交的 bitmap来确定<br>
bitmap还有很多例子用来提升分析查询的性能，可以参考论文：<br>
《Improved query performance with variant indexes》<br>
当前Oracle使用bitmap索引来对B+ 树做补充，DB2只提供了有限的版本；Sybase广泛使用了bitmap<br>
bitmap对于更新场景代价很大，所以只适用于数据仓库环境</p>
<h4 id="fast-load">Fast Load</h4>
<p>通常数据仓库在半夜将事务数据加载进来<br>
因为零售商一般是白天开门；另外整夜导入避免了用户的交互影响<br>
商业分析师可能希望做某些ad-hoc查询，比如探索飓风对于用户购买行为的影响；通常这样的查询后面还会跟着后续的探索行为，比如分析大暴风对于购买行为的影响   <br>
这两类查询应该是兼容的，也就是说他们应该是基于相同的数据之上做的；如果此时数据还在不断加载，那么查询会包含当前的历史数据，就有问题了</p>
<p>对于数据仓库来说，必须要快速的加载数据<br>
数据仓库可以使用传统的 insert方式来批量插入，但是实际从不会这么用<br>
数据仓库会将大量流数据导入存储中，而不需要经过SQL层的开销，这是利用了特殊的buld-load方式，类似B+树这样的<br>
这种方式大约比SQL插入块一个数量级，所有的驻留厂商都提供了高性能的bulk loader</p>
<p>随着世界向电子商务和24小时全天候销售转移，这种批量导入的策略，但是走向 实时数仓还是有一些问题</p>
<ul>
<li>无论是批量导入还是insert，都需要写锁，在查询时会跟读锁冲突，导致查询卡主</li>
<li>多个查询要保持兼容性可能会有问题</li>
</ul>
<p>这两个问题可以通过避免原地更新，提供提供历史数据来规避掉<br>
如果保持了之前、之后的值，并加上合适的时间戳，那么就可以提供最近的查询<br>
运行同一历史时间的查询集合，可以保持兼容的结果，相同的历史查询在执行时也不需要读锁<br>
多版本并发控制，MVCC 隔壁级别如：SNAPSHOT ISOLATION<br>
Oralce就提供了这种功能，实时的数仓就变的流行起来，而其他的供应商可能也会跟进</p>
<h4 id="materialized-views">Materialized Views</h4>
<p>数据仓库通常非常大，而且带有多个表的join查询，会执行非常长的时间，为了加速查询，很多供应商提供了物化视图<br>
不像普通的逻辑视图，物化视图是可以被查询的实际表，但是对应于一个真实表之上的逻辑视图<br>
查询一个物化视图，可以避免在运行期间执行join查询，但是物化视图必须在数据更新时保持最新的数据<br>
物化视图的使用有三个</p>
<ul>
<li>选择一个视图做物化</li>
<li>维持一个视图的新鲜数据</li>
<li>把物化视图当做ad-hoc查询</li>
</ul>
<p>(a)是4.3节中讨论的数据库自动调优的高级方案<br>
(c)在不同产品中有不同的实现，即使对于简单的单块查询，也有挑战<br>
对于带有聚合和子查询的通用SQL更是如此<br>
对于(b)大多数供应商提供多种刷新技术</p>
<ul>
<li>对于物化视图导出的表的每次更新，再执行一个物化视图更新</li>
<li>定期丢弃并创建新的物化视图</li>
</ul>
<p>这两种方案需要做权衡，第一种实时性好但是会有运行时开销<br>
第二种开销小，但是会有数据一致性问题</p>
<h4 id="olap-and-ad-hoc-query-support">OLAP and Ad-hoc Query Support</h4>
<p>一些数据仓库有预测查询，比如，对于每个月末，会运行一个总结的销售报告，对于零售链中每个销售区域部门<br>
在此工作负载中穿插着由业务分析人员动态制定的特别查询<br>
显然，这可以构造物化视图来支持，更一般的来说，大多数企业的查询要求聚合<br>
这样可以使用物化视图，对每个商店按部门汇总销售额，如果指定了上述区域查询<br>
可以通过 每个区域中的独立商店做 rolling up来满足</p>
<p>这种聚合通常被称为：数据立方体 data cube，是一种有趣的物化视图<br>
在1990年代的产品如	Essbase 提供了定制工具，以优先级cube格式来存储数据，并提供基于cube 的用户接口，来导航数据<br>
这种能力被称为 OLAP<br>
随着时间推移，data cube被添加到全功能的关系数据库系统中，经常称为 关系OLAP ROLAP <br>
很多提供ROLAP的DBMS，现在已经演化为可以内部实现一些早期的OLAP风格的存储模式(特殊case下)，结果就变成了 HOLAP，混合的OLAP<br>
data cube为可以预测的场景提供了高性能，但对于 ad-hoc 场景，通常没什么帮助</p>
<h4 id="optimization-of-snowflake-schema-queries">Optimization of Snowflake Schema Queries</h4>
<p>很多数据仓库都有一个特别的模式设计方法<br>
他们存储了事实集合在销售环境中，一条记录类似：<br>
客户 X 买了产品 Y 来自商店 Z，时间为 T <br>
一个中央的事实表记录了每次事实的信息，如采购架构，折扣，销售税率信息等等<br>
事实表通过外键关联到每个维度表，维度表可以包括</p>
<ul>
<li>客户</li>
<li>产品</li>
<li>商店</li>
<li>时间</li>
<li>等等</li>
</ul>
<p>一种经常使用的模式叫做：星型模型<br>
因为它有一个中央的事实表，其他维度表都环绕着它<br>
事实表有 1：N的 主键-外键的关联，在实体关系图中绘制这种模式是星型的 <br>
很多维度表有天然的层次关系，比如 商店可以聚合到一个区域，那么商店的维度表，可以增加一个外键，到区域维度表<br>
类似的层次如属性引用时间，月、日、年，管理的层级系统等等<br>
在这个case中，是一个 多级的星型，也叫做：雪花模型</p>
<p>本质上，所有的数据仓库查询都需要在这些表的某些属性上，过滤一个、多个雪花模型维度<br>
在join这个结果到中央事实表，在事实表、维度表上做group，然后计算SQL聚合</p>
<p>随着时间推移，供应商们在他们的 优化器中，有一类特殊的查询，因为这些很流行，而对于长时间运行的命令来说，选择一个好的查询计划非常重要</p>
<h4 id="data-warehousing-conclusions">Data Warehousing: Conclusions</h4>
<p>我们已经看到了，数据仓库跟传统的OLTP非常不同</p>
<ul>
<li>相比于B+树，他需要bitmap索引</li>
<li>相比于通用目的的优化，它需要特别注意雪花模型之上的聚合查询</li>
<li>相比于普通视图，它需要物化视图</li>
<li>相比于快速的事务更新，它需要快速的批量导入等等</li>
</ul>
<p>相关文章：<br>
《An overview of data warehousing and olap technology》</p>
<p>一开始主要的供应商提供面向 OLTP的架构，之后增加了数据仓库特性<br>
之后，各种小的供应商提供了 DBMS的解决方案，如：</p>
<ul>
<li>Teradata</li>
<li>Netezza</li>
</ul>
<p>他们使用的是 shared-nothing的专有硬件，其他的厂商有：</p>
<ul>
<li>Greenplum，并行化的PG</li>
<li>DATAllegro</li>
<li>EnterpriseDB</li>
</ul>
<p>他们可以运行在廉价的硬件机器之上</p>
<p>有些人宣称列存储在数据仓库领域有巨大的优势，传统的存储引擎是行存的<br>
当表很宽时，并且只需要访问少数几个列时，使用列存就很有效<br>
列存对数据压缩也很有效，因为都是相同类型的数据<br>
挑战</p>
<ul>
<li>跨多列存储时，表中行位置需要保持一致性</li>
<li>需要额外的机制实现多个列的join</li>
</ul>
<p>这对于OLTP来说是一个大问题，但对于大多数都是append场景的数据仓库、日志存储系统来说，不是什么问题<br>
主要的供应商有</p>
<ul>
<li>Sybase</li>
<li>Vertica</li>
<li>Sand</li>
<li>Vhayu</li>
<li>KX</li>
</ul>
<p>几个文章</p>
<ul>
<li>《Performance tradeoffs in read-optimized databases</li>
<li>《C-store: A column oriented dbms》</li>
<li>《One size fits all: An idea whose time has come and gone》</li>
</ul>
<h3 id="database-extensibility">Database Extensibility</h3>
<p>关系型数据库传统上被认为是存储数据类型有限制，在公司和管理记录系统中，存储事实和数字<br>
不过今天有各种各样的数据类型，出现在各种程序语言中<br>
这是通过DBMS的各种方式扩展来实现的，这章来简单介绍下各种扩展数据<br>
在交付实现时候会出现各种扩展，强调交付此可扩展性时出现的一些体系结构问题<br>
这些特性在今天的大多数商业DBMS中都有不同程度的出现，在开源的PostgreSQL DBMS中也有</p>
<h4 id="abstract-data-types">Abstract Data Types</h4>
<p>理论上，关系模型与可以放置在模式列上的标量数据类型的选择无关  <br>
但是，最初的关系数据库系统只支持一组静态的字母数字列类型，而这种限制与关联模型本身有关</p>
<p>DBMS可以在运行时扩展数据类型，正如早起的Ingres ADT系统，以及后期的跟随者 Postgre系统<br>
DBMS类型系统，解析器需要从系统目录驱动，维持已知的类型列表，指向被使用的method(code)，来维持这些类型<br>
这种方式，DBMS不需要解释类型，只是在表达式求值的时候，适当的调用其method，因此叫做：抽象数据类型<br>
比如，可以注册一个二维空间类型 矩形，然后提供矩形的相交、并集等操作<br>
这就意味着系统必须为用户代码提供一个运行时引擎，并且要确保执行的安全性，比如代码不能导致数据库崩溃或者数据损坏</p>
<p>今天主要的DBMS都允许用户通过 一个重要的“存储过程”现代SQL子语言，来订阅他们的功能<br>
大多数都支持至少一种语言，如C、Java<br>
在windows平台中，SQLServer和DB2支持代码编译到 .net运行环境，可以用各种语言来书写，比如VB、C++、C#等<br>
PG支持C、perl、python、Tcl、并允许在运行时增加一个新语言，如流行的第三方插件 ruby和统计包R</p>
<p>未确保抽象数据类型在运行期间的高效，查询优化器需要在 select、join时候谨慎对待用户定义的代码<br>
有些case会推迟 selelct，直到join完成后<br>
为了使 ADT 事件更有效，会在其上定义索引，比如，B+树 需要扩展到 ADT上的索引表达式，而不是仅仅是列(有时叫：函数索引)，当他们被应用时，优化器会扩展选择他们 <br>
对于线性顺序以外的谓词，如非 &lt; 、&gt;、=，此时B+ 树就不再有效，系统需要支持扩展的索引模式</p>
<ul>
<li>原始的PG扩展访问模式接口</li>
<li>GiST</li>
</ul>
<h4 id="structured-types-and-xml">Structured Types and XML</h4>
<p>ADT被设置全完兼容关系模型，不需要修改任何基本的关系代码，只需要改变属性值之上的表达式<br>
过了多年之后，又提出了很多激进的提案，希望DB能支持 非关系结构类型</p>
<ul>
<li>内嵌的列类型如数组、sets、tree</li>
<li>嵌套的tuple</li>
<li>关系</li>
</ul>
<p>可能今天这些提案中最相关的是，通过XPath、XQuery等语言支持XML<br>
处理XML这样的结构化类型大概有三种方式</p>
<ul>
<li>建立一个自定义的数据库系统，对结构化类型的数据进行操作；从历史上看，这些尝试都被适应传统关系DBMS中的结构化类型的方法所掩盖，XML也遵循了这个趋势</li>
<li>用ADT的方式存储复杂类型，比如定义XML类型列的关系表，然后每行存储一个XML文档，这意味着搜索XML，使用XPath树匹配的方式，这个执行方式对优化器是不透明的</li>
<li>将内嵌结构规范化，在insert的时候，将用外键将子对象和父类连接起来；这种方式叫分解XML，它导出所有数据结构到DBMS关系框架中，但增加了存储开销，在查询时需要重新连接这些数据</li>
</ul>
<p>今天大多数供应商都提供了 ADT 和分解方式来存储，并允许数据库设计者选择他们<br>
XML例子中，分解方式也很常见，它提供了删除同层级XML元素之间排序信息的 选项
它提升了查询性能：允许join重排序、其他关系优化</p>
<p>一个相关问题是，对关系模型做适度的扩展，用于处理内嵌的表和tuple，以及数组   <br>
这杯广泛的用在Oracle里面，这些设计的权衡跟处理XML类似</p>
<h4 id="full-text-search">Full-Text Search</h4>
<p>传统上，关系数据库对于处于富文本数据，以及关键检索方面被认为是比较差的</p>
<h4 id="additional-extensibility-issues">Additional Extensibility Issues</h4>
<h3 id="standard-practice-2">Standard Practice</h3>
<h3 id="discussion-and-additional-material-2">Discussion and Additional Material</h3>
<h2 id="storage-management">Storage Management</h2>
<p>。。。</p>
<h2 id="transactions-concurrency-control-and-recovery">Transactions: Concurrency Control and Recovery</h2>
<p>。。。</p>
<h2 id="shared-components">Shared Components</h2>
<p>。。。</p>
<h2 id="conclusion">Conclusion</h2>
<p>。。。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/447307687">Oracle RAC技术简介</a></li>
<li><a href="https://www.cnblogs.com/mlmz/p/16168285.html">Architecture of a Database System阅读</a></li>
<li><a href="https://courses.cs.duke.edu/compsci516/cps216/spring03/papers/selinger-etal-1979.pdf">Access path selection in a relational database management system</a></li>
</ul>
<p>paper</p>
<ul>
<li>System R优化器(1979年的一篇著名论文)：《Access path selection in a relational database management system》</li>
<li>查询优化的圣经 《Access path selection in a relational database management system》</li>
<li>《Optimization of parallel query execution plansin xprs》</li>
<li>《Query evaluation techniques for large databases》</li>
<li>《Encapsulation of parallelism in the volcano query processing system》</li>
<li>《Improved query performance with variant indexes》</li>
<li>《An overview of data warehousing and olap technology》</li>
<li>《Performance tradeoffs in read-optimized databases</li>
<li>《C-store: A column oriented dbms》</li>
<li>《One size fits all: An idea whose time has come and gone》</li>
</ul>

			<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
        </div>

        


        

<div class="post-archive">
    <h2>相关文章</h2>
    <ul class="listing">
        
        <li><a href="/post/2022/08/a-relational-model-of-data-for-large-shared-data-banks/">A Relational Model of Data for Large Shared Data Banks论文翻译</a></li>
        
        <li><a href="/post/2022/08/%E7%A1%AE%E5%AE%9A%E8%A6%81%E5%9C%A8dbms%E4%B8%AD%E7%94%A8mmap%E5%90%97/">确定要在DBMS中用mmap吗</a></li>
        
        <li><a href="/post/2022/08/%E4%B8%BA%E4%BD%95uber%E8%A6%81%E5%B0%86postgresql%E8%BF%81%E5%88%B0mysql/">为何Uber要将PostgreSQL迁到MySQL</a></li>
        
        <li><a href="/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B/">卡内基梅隆的数据库课程-1</a></li>
        
        <li><a href="/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B-2/">卡内基梅隆的数据库课程-2</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/%E6%95%B0%E6%8D%AE%E5%BA%93'>数据库</a></li>
                
                <li><a href='/tags/%E8%AE%BA%E6%96%87'>论文</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>


                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://code0xff.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://code0xff.cn/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://code0xff.cn/post/2022/10/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/" title="容器网络">容器网络</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/10/b&#43;%E6%A0%91%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" title="B&#43;树执行过程">B&#43;树执行过程</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/09/k8s%E4%BD%BF%E7%94%A8/" title="k8s POD使用总结">k8s POD使用总结</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/09/architecture-of-a-database-system/" title="Architecture of a Database System论文翻译">Architecture of a Database System论文翻译</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/08/a-relational-model-of-data-for-large-shared-data-banks/" title="A Relational Model of Data for Large Shared Data Banks论文翻译">A Relational Model of Data for Large Shared Data Banks论文翻译</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/08/%E7%A1%AE%E5%AE%9A%E8%A6%81%E5%9C%A8dbms%E4%B8%AD%E7%94%A8mmap%E5%90%97/" title="确定要在DBMS中用mmap吗">确定要在DBMS中用mmap吗</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/08/%E4%B8%BA%E4%BD%95uber%E8%A6%81%E5%B0%86postgresql%E8%BF%81%E5%88%B0mysql/" title="为何Uber要将PostgreSQL迁到MySQL">为何Uber要将PostgreSQL迁到MySQL</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B/" title="卡内基梅隆的数据库课程-1">卡内基梅隆的数据库课程-1</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B-2/" title="卡内基梅隆的数据库课程-2">卡内基梅隆的数据库课程-2</a>
    </li>
    
    <li>
        <a href="https://code0xff.cn/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B-3/" title="卡内基梅隆的数据库课程-3">卡内基梅隆的数据库课程-3</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://code0xff.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式 (6)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E5%95%86%E4%B8%9A/">商业 (3)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据 (16)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库 (6)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E6%97%85%E8%A1%8C/">旅行 (10)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E6%9E%B6%E6%9E%84/">架构 (1)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E7%AE%97%E6%B3%95/">算法 (8)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E7%B3%BB%E7%BB%9F/">系统 (4)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言 (2)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 (9)</a></li>
    
    <li><a href="https://code0xff.cn/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/">随便写写 (4)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">归档</a></h3>
<ul class="widget-list">
    
    <li><a href="https://code0xff.cn/years/2021%E5%B9%B4/">2021年 (30)</a></li>
    
    <li><a href="https://code0xff.cn/years/2022%E5%B9%B4/">2022年 (39)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://code0xff.cn/tags/b%E6%A0%91/">B树 </a>
    
    <a href="https://code0xff.cn/tags/hive/">Hive </a>
    
    <a href="https://code0xff.cn/tags/k8s/">k8s </a>
    
    <a href="https://code0xff.cn/tags/kudu/">kudu </a>
    
    <a href="https://code0xff.cn/tags/manacher/">Manacher </a>
    
    <a href="https://code0xff.cn/tags/mapreduce/">MapReduce </a>
    
    <a href="https://code0xff.cn/tags/paxos/">paxos </a>
    
    <a href="https://code0xff.cn/tags/raft/">raft </a>
    
    <a href="https://code0xff.cn/tags/scala/">scala </a>
    
    <a href="https://code0xff.cn/tags/snowflake/">snowflake </a>
    
    <a href="https://code0xff.cn/tags/spark/">spark </a>
    
    <a href="https://code0xff.cn/tags/unix/">unix </a>
    
    <a href="https://code0xff.cn/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找 </a>
    
    <a href="https://code0xff.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">二叉树遍历 </a>
    
    <a href="https://code0xff.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式 </a>
    
    <a href="https://code0xff.cn/tags/%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5/">动态注入 </a>
    
    <a href="https://code0xff.cn/tags/%E5%8E%86%E5%8F%B2/">历史 </a>
    
    <a href="https://code0xff.cn/tags/%E5%9B%9E%E6%BA%AF/">回溯 </a>
    
    <a href="https://code0xff.cn/tags/%E5%9B%BD%E5%86%85%E6%97%85%E8%A1%8C/">国内旅行 </a>
    
    <a href="https://code0xff.cn/tags/%E5%9B%BD%E5%A4%96%E6%97%85%E8%A1%8C/">国外旅行 </a>
    
    <a href="https://code0xff.cn/tags/%E5%AD%98%E5%82%A8/">存储 </a>
    
    <a href="https://code0xff.cn/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/">工作记录 </a>
    
    <a href="https://code0xff.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务 </a>
    
    <a href="https://code0xff.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库 </a>
    
    <a href="https://code0xff.cn/tags/%E6%B1%87%E7%BC%96/">汇编 </a>
    
    <a href="https://code0xff.cn/tags/%E6%B9%96%E4%BB%93%E4%B8%80%E4%BD%93/">湖仓一体 </a>
    
    <a href="https://code0xff.cn/tags/%E7%94%9F%E6%B4%BB/">生活 </a>
    
    <a href="https://code0xff.cn/tags/%E7%94%B5%E5%BD%B1/">电影 </a>
    
    <a href="https://code0xff.cn/tags/%E7%AE%97%E6%B3%95/">算法 </a>
    
    <a href="https://code0xff.cn/tags/%E7%BB%8F%E6%B5%8E/">经济 </a>
    
    <a href="https://code0xff.cn/tags/%E7%BC%93%E5%AD%98/">缓存 </a>
    
    <a href="https://code0xff.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理 </a>
    
    <a href="https://code0xff.cn/tags/%E7%BD%91%E7%BB%9C/">网络 </a>
    
    <a href="https://code0xff.cn/tags/%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/">计算框架 </a>
    
    <a href="https://code0xff.cn/tags/%E8%AE%BA%E6%96%87/">论文 </a>
    
    <a href="https://code0xff.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 </a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">RSS</h3>
        <ul class="widget-list">
            <li><a href="https://code0xff.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div>
        &copy; 2022 <a href="https://code0xff.cn/">记录每个瞬间 By 老王</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
    <div>
        <a href="http://www.beian.miit.gov.cn/">京ICP备19014975号</a>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'GA ID', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>

</html>