<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>卡内基梅隆的数据库课程-1 | 记录每个瞬间</title>
    <meta property="og:title" content="卡内基梅隆的数据库课程-1 - 记录每个瞬间">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2022-07-22T20:32:19&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2022-07-22T20:32:19&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="卡内基梅隆的数据库课程-1">
        <meta name="author" content="隔壁老王">
        
    <meta property="og:url" content="https://code0xff.org/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
        <link href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" rel="stylesheet">
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://code0xff.org/">
                        记录每个瞬间
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://code0xff.org/">首页</a>
                    
                    <a  href="https://code0xff.org/linked/" title="链接">链接</a>
                    
                    <a  href="https://code0xff.org/archives/" title="归档">归档</a>
                    
                    <a  href="https://code0xff.org/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">卡内基梅隆的数据库课程-1</h1>
        </header>
        <date class="post-meta meta-date">
            2022年7月22日
        </date>
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#backgroup">Backgroup</a></li>
        <li><a href="#database-storage">Database Storage</a></li>
        <li><a href="#buffer-pool">Buffer Pool</a></li>
        <li><a href="#hash-table">Hash Table</a></li>
        <li><a href="#table-index">Table Index</a></li>
        <li><a href="#index-concurrency-control">Index Concurrency Control</a></li>
        <li><a href="#sorting--aggregations">Sorting + Aggregations</a></li>
        <li><a href="#joins-algorithms">Joins Algorithms</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
        
        <div class="post-meta">
            
            <span class="post-meta meta-tags">
                <ul class="clearfix">
                    <a href='/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0'>读书笔记</a>
                </ul>
            </span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <blockquote>
<p>课程地址<br>
<a href="https://15445.courses.cs.cmu.edu/fall2021/schedule.html">https://15445.courses.cs.cmu.edu/fall2021/schedule.html</a></p>
</blockquote>
<h2 id="backgroup">Backgroup</h2>
<blockquote>
<p>A database management system (DBMS) is software that allows applications to store and analyze information in a database.</p>
<p>A general-purpose DBMS is designed to allow the definition, creation, querying, update, and administration of databases.</p>
</blockquote>
<p>发展历史</p>
<ul>
<li>早起的数据存储、数据管理是 紧耦合的</li>
<li>1960年代末期，有学者提议将数据和操作分离</li>
<li>1970年代，codd 提出了关系模型，将存储和操作分离，并提供了高级操作API</li>
<li>访问是通过高层语言，DBMS找到最佳的访问策略，物理存储留给DBMS实现</li>
</ul>
<p>数据模型</p>
<ul>
<li>Relational   Most DBMS</li>
<li>Key/value     nosql</li>
<li>Graph</li>
<li>Doucument</li>
<li>Column-family</li>
<li>Array/Matrix   machine learning</li>
<li>hierarchical   obsolete/legacy/rare</li>
<li>network</li>
<li>multi-value</li>
</ul>
<p>Current standard is SQL:2016</p>
<ul>
<li>SQL:2016 → JSON, Polymorphic tables</li>
<li>SQL:2011 → Temporal DBs, Pipelined DML</li>
<li>SQL:2008 → Truncation, Fancy Sorting</li>
<li>SQL:2003 → XML, Windows, Sequences, Auto-Gen IDs.</li>
<li>SQL:1999 → Regex, Triggers, OO</li>
</ul>
<p>将查询结果保存到另一个表中</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">DISTINCT</span> cid <span style="color:#ff79c6">INTO</span> CourseIds <span style="color:#ff79c6">FROM</span> enrolled;  <span style="color:#ff79c6">#</span> SQL92
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">TABLE</span> CourseIds (<span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">DISTINCT</span> cid <span style="color:#ff79c6">FROM</span> enrolled); <span style="color:#ff79c6">#</span> MySQL
</span></span></code></pre></td></tr></table>
</div>
</div><p>子查询很难优化</p>
<ul>
<li>ALL，Must satisfy expression for all rows in the sub-query.</li>
<li>ANY，Must satisfy expression for at least one row in the sub-query.</li>
<li>IN，Equivalent to &lsquo;=ANY()&rsquo; .</li>
<li>EXISTS，At least one row is returned.</li>
</ul>
<p>关系代数

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggXnc.png">
            <img class="mx-auto" alt="relational algebra-1" src="https://v1.ax1x.com/2024/05/28/7ggXnc.png" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggJcf.png">
            <img class="mx-auto" alt="relational algebra-2" src="https://v1.ax1x.com/2024/05/28/7ggJcf.png" />
        </a>
    </p>
<p>数据库的层次结构<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gg5o7.png">
            <img class="mx-auto" alt="Database Storage-1" src="https://v1.ax1x.com/2024/05/28/7gg5o7.png" />
        </a>
    </p>
<p>相关文章</p>
<ul>
<li><a href="https://dl.acm.org/doi/10.1145/1558334.1558336">Derivability, redundancy and consistency of relations stored in large data banks</a></li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/362384.362685">A relational model of data for large shared data banks</a></li>
<li><a href="https://db.cs.cmu.edu/files/sql/sql1992.txt">SQL 1992</a></li>
</ul>
<h2 id="database-storage">Database Storage</h2>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggVyI.png">
            <img class="mx-auto" alt="Database Storage-2" src="https://v1.ax1x.com/2024/05/28/7ggVyI.png" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggWUV.png">
            <img class="mx-auto" alt="Database Storage-3" src="https://v1.ax1x.com/2024/05/28/7ggWUV.png" />
        </a>
    </p>
<p>用 OS来管理内存</p>
<ul>
<li>mmap来映射文件内容，到用户程序地址空间中</li>
<li>OS 负责in/out内存</li>
</ul>
<p>OS管理内存的问题</p>
<ul>
<li>只读会很好，并发情况下不好处理</li>
<li>madvise，告诉OS期待读的特定page</li>
<li>mlock，一段内存不要换出</li>
<li>msync，将内存flush到磁盘</li>
<li>flush脏页</li>
<li>指定的预抓取</li>
<li>buffer替换策略</li>
<li>线程、进程调度</li>
<li>DBMS根据SQL得到查询计划，可以更好的管理内存： 内存分配、预抓取、驱逐策略</li>
</ul>
<p>数据库的page布局</p>
<ul>
<li>硬件一般是4K</li>
<li>数据库 512B - 16K</li>
<li>Oracle 4K、SqlServer/PG 8K、MySQL 16K</li>
</ul>
<p>page的文件布局方式</p>
<ul>
<li>linked list布局</li>
<li>page directory布局</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggxta.png">
            <img class="mx-auto" alt="Database Storage-4" src="https://v1.ax1x.com/2024/05/28/7ggxta.png" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggG8s.png">
            <img class="mx-auto" alt="Database Storage-5" src="https://v1.ax1x.com/2024/05/28/7ggG8s.png" />
        </a>
    </p>
<p>页布局方式</p>
<ul>
<li>slotted pages</li>
<li>每个数据库都会包含一个唯一ID，page_id + offset/slot 组成的</li>
<li>log-structured file organization</li>
<li>level compaction

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggc2L.png">
            <img class="mx-auto" alt="Database Storage-6" src="https://v1.ax1x.com/2024/05/28/7ggc2L.png" />
        </a>
    </li>
</ul>
<p>tuple 布局</p>
<ul>
<li>本质上市一系列的byte</li>
<li>DBMS的任务是解释这些字节到 属性和值中</li>
<li>DBMS的catalog包含关于表的schema信息，使用这些信息，系统就可以找到表的布局</li>
<li>物理的非规范化表示，关联的tuple存储在相同page中</li>
<li>比如foo表和bar表，bar表的外键指向foo表主键，将foo表内容全部内嵌到bar表中</li>
<li>通常可以减少I/O数量，但update代价更高</li>
<li>Not a new idea, IBM System R dis this in 1970s</li>
<li>Several NoSQL DBMSs do this without calling it physical denormalization<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggaEJ.jpg">
            <img class="mx-auto" alt="Database Storage-6-1" src="https://v1.ax1x.com/2024/05/28/7ggaEJ.jpg" />
        </a>
      <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggDcG.jpg">
            <img class="mx-auto" alt="Database Storage-6-2" src="https://v1.ax1x.com/2024/05/28/7ggDcG.jpg" />
        </a>
    </li>
</ul>
<p>日志结构合并树<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggOnB.jpg">
            <img class="mx-auto" alt="Database Storage-6-3" src="https://v1.ax1x.com/2024/05/28/7ggOnB.jpg" />
        </a>
    </p>
<p>数据表示</p>
<ul>
<li>decimal类型，底层是用各种int存储的</li>
<li>int ndigist、int weight、int scale、int sign</li>
<li><a href="https://doxygen.postgresql.org/interfaces_2ecpg_2pgtypeslib_2numeric_8c_source.html#l00722">pg的decimal表示</a></li>
<li><a href="https://github.com/mysql/mysql-server/blob/8.0/strings/decimal.cc#L1828">mysql的decimal表示</a></li>
<li>超长的值，用 overflow存储页实现</li>
<li>外部数据存储，如Oracle的BFILE类型，指向一个外部文件，但DB不负责管理此文件</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggPte.png">
            <img class="mx-auto" alt="Database Storage-7" src="https://v1.ax1x.com/2024/05/28/7ggPte.png" />
        </a>
    </p>
<p>大值的存储</p>
<ul>
<li>DBMS使用了一个独立的页，overflow，来存储这个page</li>
<li>将大值存储在一个额外的文件中，当做BLOB类型</li>
<li>Oracle BFILE数据类型，SQLServer的FILESTREAM 类型</li>
<li>数据库不管理这些额外文件的内容，没有持久化保证，没有事务保证

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggUpt.png">
            <img class="mx-auto" alt="Database Storage-8" src="https://v1.ax1x.com/2024/05/28/7ggUpt.png" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gg1Gb.png">
            <img class="mx-auto" alt="Database Storage-9" src="https://v1.ax1x.com/2024/05/28/7gg1Gb.png" />
        </a>
    </li>
</ul>
<p>系统catalog</p>
<ul>
<li>存储数据库的元数据到内部catalog中</li>
<li>表、列、索引、视图</li>
<li>用户、权限，内部统计信息</li>
<li>对这些tuple做包装抽象</li>
<li>特殊的代码寻找这些catalog表</li>
</ul>
<p>系统catalog，标准SQL 92语法</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">FROM</span> INFORMATION_SCHEMA.TABLES
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">WHERE</span> table_catalog <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;&lt;db name&gt;&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>各种场景</p>
<ul>
<li>OLTP</li>
<li>OLAP</li>
<li>HTAP</li>
</ul>
<p>数据存储模型</p>
<ul>
<li>N-ary storage model NSM，适合行存</li>
<li>decomposition storage model DSM，适合列存</li>
</ul>
<p>N-ary的存储模式</p>
<ul>
<li>适合快速的增删改查</li>
<li>对于需要整个tuple的场景也合适</li>
<li>对于需要扫描表的大部分数据则不合适</li>
<li>对于只查找部分属性也不合适<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggCQQ.jpg">
            <img class="mx-auto" alt="Database Storage-10" src="https://v1.ax1x.com/2024/05/28/7ggCQQ.jpg" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggRoP.jpg">
            <img class="mx-auto" alt="Database Storage-11" src="https://v1.ax1x.com/2024/05/28/7ggRoP.jpg" />
        </a>
    </li>
</ul>
<p>decomposition storage model存储模式</p>
<ul>
<li>减少了总I/O数量，DBMS只需要读取需要的数据</li>
<li>更好的查询处理和数据压缩</li>
<li>对于点查、insert、update、delete都比较慢，因为tuple需要分解、缝合

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggrHw.jpg">
            <img class="mx-auto" alt="Database Storage-12" src="https://v1.ax1x.com/2024/05/28/7ggrHw.jpg" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggtU6.jpg">
            <img class="mx-auto" alt="Database Storage-13" src="https://v1.ax1x.com/2024/05/28/7ggtU6.jpg" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggz2O.jpg">
            <img class="mx-auto" alt="Database Storage-14" src="https://v1.ax1x.com/2024/05/28/7ggz2O.jpg" />
        </a>
    </li>
</ul>
<p>相关文章</p>
<ul>
<li><a href="https://www.morganclaypool.com/doi/10.2200/S00891ED1V01Y201812DTM055">Non-Volatile Memory Database Management Systems</a></li>
<li><a href="https://en.wikipedia.org/wiki/IEEE-754">IEEE754</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/to-blob-or-not-to-blob-large-object-storage-in-a-database-or-a-filesystem/">To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</a></li>
<li><a href="https://dl.acm.org/doi/10.5555/645472.655555">A Query Processing Strategy for the Decomposed Storage Model</a></li>
</ul>
<h2 id="buffer-pool">Buffer Pool</h2>
<p>目标</p>
<ul>
<li>让经常一起使用的页，物理布局尽可能靠近</li>
<li>尽量减少读/写 地盘的次数</li>
</ul>
<p>buffer pool</p>
<ul>
<li>按照数组方式组织的，固定大小的多个页</li>
<li>一个数组条目叫做： frame</li>
<li>page table维护了当前哪些页在内存中</li>
<li>也维护了一些元信息：脏页标记、固定页(不换出)、引用计数</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggKEH.png">
            <img class="mx-auto" alt="buffer-pool-1" src="https://v1.ax1x.com/2024/05/28/7ggKEH.png" />
        </a>
    </p>
<p>locks vs latches</p>
<ul>
<li>锁在事务时保护数据的逻辑；锁闩包含并发时数据内不会被其他线程写坏</li>
<li>锁只在事务中；锁闩在更长时间内</li>
<li>锁需要能被rollback；锁闩不需要</li>
</ul>
<p>page table VS page directory</p>
<ul>
<li>页字典维护了：数据库文件中 page id 到具体位置的映射，需要写入到磁盘</li>
<li>页表：page id 到缓冲池frame的映射，不需要持久化</li>
</ul>
<p>分配策略</p>
<ul>
<li>全局策略，对于所有活跃的事务</li>
<li>本地策略，分配frame对于一个指定的事务，但仍需要支持共享page</li>
</ul>
<p><strong>buffer pool优化</strong></p>
<ul>
<li>多个buffer pool，如每个数据库的buffer pool，每个页类型的buffer pool</li>
<li>预抓取</li>
<li>scan共享</li>
<li>buffer pool bypass</li>
</ul>
<p>多个buffer pool</p>
<ul>
<li>一条记录如何找到一个固定的buffer pool的？</li>
<li>通过object id</li>
<li>通过hash， GET RECORD 123，计算 hash(123)%n，找到具体的缓冲池</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gguyh.png">
            <img class="mx-auto" alt="buffer-pool-2" src="https://v1.ax1x.com/2024/05/28/7gguyh.png" />
        </a>
    </p>
<p>预抓取</p>
<ul>
<li>基于查询计划，可以提前抓取一些页</li>
<li>顺序扫描</li>
<li>索引扫描</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggwU9.png">
            <img class="mx-auto" alt="buffer-pool-3" src="https://v1.ax1x.com/2024/05/28/7ggwU9.png" />
        </a>
    </p>
<p>基于索引的预抓取，假设有如下SQL</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">FROM</span> A <span style="color:#ff79c6">WHERE</span> val <span style="color:#ff79c6">BETWEEN</span> <span style="color:#bd93f9">100</span> <span style="color:#ff79c6">AND</span> <span style="color:#bd93f9">250</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggysY.png">
            <img class="mx-auto" alt="buffer-pool-4" src="https://v1.ax1x.com/2024/05/28/7ggysY.png" />
        </a>
    <br>
如上，在扫描索引时，会加载 index-page0、index-page1，之后就会把 index-page3、index-page5都加载到内存中</p>
<p>scan共享</p>
<ul>
<li>查询可以重用 存储、操作计算的数据检索</li>
<li>也叫作 synchronized scans</li>
<li>跟结果缓存不同</li>
<li>可以让多个线程附属到一个scan游标上,Oracle、PG、mysql</li>
<li>查询可以不是相同的</li>
<li>可以共享中间结果</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggNe4.png">
            <img class="mx-auto" alt="buffer-pool-5" src="https://v1.ax1x.com/2024/05/28/7ggNe4.png" />
        </a>
    <br>
如上，查询1当前已经将 page-3、page-1、page-2放入了缓冲池中<br>
查询2 来了，可以共享之前的页，注意看 查询2和查询1不是完全相同的，但是可以重用一些页<br>
于是查询2 共享了查询1的游标</p>
<p>buffer poll bypass</p>
<ul>
<li>需要大量顺序扫描，此时页会不断的放入内存，造成不必要的开销</li>
<li>本地内存查询</li>
<li>临时文件，如排序，join时候</li>
</ul>
<p>OS page</p>
<ul>
<li>默认情况下，读取文件时，操作系统会将其缓存</li>
<li>使用裸OS，O_DIRECT可以绕过操作系统缓存</li>
<li>避免重复拷贝</li>
<li>需要定义自己的驱逐策略</li>
</ul>
<p>PG的一个查询例子</p>
<ul>
<li>SELECT pg_prewarm(&rsquo;testreals&rsquo;)</li>
<li>SHOW shared_buffers;</li>
</ul>
<p>buffer替换策略</p>
<ul>
<li>目标：正确性、准确性、速度、元数据的开销</li>
<li>LRU算法</li>
<li>clock算法，类似于LRU，但是不需要每个页指明timestamp</li>
<li>每个页都有一个bit引用，当访问时设置为1</li>
<li>组织页为一个环形buffer类似时钟，当清扫时碰到1设置为0，碰到0时则驱逐</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggbWZ.png">
            <img class="mx-auto" alt="buffer-pool-6" src="https://v1.ax1x.com/2024/05/28/7ggbWZ.png" />
        </a>
    <br>
如上，clock算法，顺时针扫描每个页，page1一开始是1，然后被设置为0，之后扫描到page2位0，将其驱逐<br>
如果每个页都是1，那么一轮下来之后，12点方向的页因为被置0了，会被驱逐</p>
<p>问题</p>
<ul>
<li>LRU和clock都会出现 sequential flooding 问题</li>
<li>顺序扫描大量页时，会造成buffer pool的污染，某些页可能就读一次，以后不再读了</li>
</ul>
<p>更好的策略</p>
<ul>
<li>LRU-K</li>
<li>以时间戳的形式，记录每个页面最后K次引用的历史，并计算后续访问之间的间隔</li>
<li>DBMS之后使用历史来估算下次被访问的时间</li>
<li>localization</li>
<li>根据每个请求、事务来决定要驱逐的页面，可以将buffer pool的污染最小化</li>
<li>PG管理一个小的环形buffer来私有化处理查询</li>
<li>priority hint</li>
<li>DBMS知道查询的上下文，可以将这个信息提供给buffer pool，判断这个页面是否重要</li>
</ul>
<p>脏页</p>
<ul>
<li>如果buffer pool中的页面不是脏的，可以简单的删掉，很快</li>
<li>脏页需要写入到磁盘，保证持久化，较慢</li>
<li>需要在 快速删除，未来可能不会再读的脏页 之间做出权衡</li>
<li>脏页被安全的写到磁盘后，DMBS可以驱逐脏页，也可以只设置脏页的flag</li>
<li>在写脏页之前，需要先记录log</li>
</ul>
<p>其他的 内存池</p>
<ul>
<li>他们不一定是基于磁盘的，看具体实现</li>
<li>排序、join buffer</li>
<li>查询 cache</li>
<li>维护buffer</li>
<li>日志buffer</li>
<li>字典cache</li>
</ul>
<p>相关文章</p>
<ul>
<li><a href="https://stackoverflow.com/questions/62185855/shared-scanning-in-postgres">Shared Scanning in Postgres</a></li>
<li><a href="https://www.postgresql.org/docs/current/runtime-config-compatible.html">Version and Platform Compatibility</a></li>
<li><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></li>
<li><a href="https://www.doxygen.nl/manual/docblocks.html">Documenting the code</a></li>
<li><a href="https://www.ibm.com/docs/en/informix-servers/12.10?topic=io-light-scans">Light scans</a></li>
<li><a href="https://linux.die.net/man/2/open">O_DIRRECT</a></li>
</ul>
<h2 id="hash-table">Hash Table</h2>
<p>主要目标</p>
<ul>
<li>内部元数据</li>
<li>核心数据存储</li>
<li>临时数据结构</li>
<li>表索引</li>
</ul>
<p>设计要点</p>
<ul>
<li>将大量的key映射到一个较小的空间中</li>
<li>快速访问和冲突比列 之间做出权衡</li>
<li>冲突之后如何处理</li>
<li>分配大hash表 和 额外的find/insert key指令 之间做出权衡</li>
</ul>
<p>hash function</p>
<ul>
<li><a href="https://create.stephan-brumme.com/crc32/">CRC-64</a> (1975)，Used in networking for error detection.</li>
<li><a href="https://github.com/aappleby/smhasher">MurmurHash</a> (2008)，Designed as a fast, general-purpose hash function.</li>
<li><a href="https://github.com/google/cityhash">Google CityHash</a> (2011)，Designed to be faster for short keys (&lt;64 bytes).</li>
<li><a href="http://cyan4973.github.io/xxHash/">Facebook XXHash</a> (2012)，From the creator of zstd compression.</li>
<li><a href="https://github.com/google/farmhash">Google FarmHash</a>，(2014)Newer version of CityHash with better collision rates</li>
</ul>
<p>不同hash函数的性能测试<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggsH4.png">
            <img class="mx-auto" alt="hash table-1" src="https://v1.ax1x.com/2024/05/28/7ggsH4.png" />
        </a>
    </p>
<p><strong>static hash schema</strong></p>
<ul>
<li>Approach #1: Linear Probe Hashing
<ul>
<li>冲突时继续往下探测</li>
<li>删除元素用墓碑替代，这样查找冲突时，就会继续往下探测</li>
<li>或者直接删除，将后面的元素全部往前移动</li>
</ul>
</li>
<li>Approach #2: Robin Hood Hashing
<ul>
<li>是 线性探测的变种，每个槽位包含了：离最佳位置的距离</li>
<li>如果新元素的 距离 &gt; 旧元素的距离，则旧元素需要重新挪位置，让位给新的</li>
</ul>
</li>
<li>Approach #3: Cuckoo Hashing</li>
</ul>
<p>非唯一key的处理方式<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggi9m.png">
            <img class="mx-auto" alt="hash table-2" src="https://v1.ax1x.com/2024/05/28/7ggi9m.png" />
        </a>
    </p>
<p>罗宾汉hash的例子<br>
E的hash跟A冲突了，A的距离是0，再往下找，C的距离是1<br>
再往下此时D的距离是1，小于E(2)，将D的位置插入E，再重新寻找D的位子<br>
罗宾汉hash的好处是，可以让所有的key距离更均衡，相当于做了 rebalance         <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggMz5.png">
            <img class="mx-auto" alt="hash table-3" src="https://v1.ax1x.com/2024/05/28/7ggMz5.png" />
        </a>
    </p>
<p>cuckoo hash冲突的例子如下：

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggIGj.png">
            <img class="mx-auto" alt="hash table-4" src="https://v1.ax1x.com/2024/05/28/7ggIGj.png" />
        </a>
    <br>
A 和 B 都找到了合适的位置，此时 insert C，hash1和hash2计算出来的都冲突<br>
hash1跟A冲突， hash2跟B冲突<br>
于是将B替换为C，重新计算B<br>
B计算出来的位置是原先A的位置，于是将 A 替换为B<br>
最后重新计算A的位置，于是放入第二个hash表中，整个过程完成</p>
<p><strong>dynamic hash schema</strong></p>
<ul>
<li>Chained Hashing
<ul>
<li>为哈希表中的每个槽维护一个桶链表</li>
<li>insert和delete泛化为lookup</li>
</ul>
</li>
<li>Extendible Hashing
<ul>
<li>链式hash的方式需要split桶，而不是让其无限增长</li>
<li>在拆分的时候需要重新shuffle</li>
</ul>
</li>
<li>Linear Hashing</li>
</ul>
<p>链式hash，每个键对应一个链表，每个节点是一个桶<br>
桶中装着发生冲突的元素，当桶满了，就再往后挂一个<br>
最坏的情况，可能会退化成链表<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggnL3.png">
            <img class="mx-auto" alt="hash table-5" src="https://v1.ax1x.com/2024/05/28/7ggnL3.png" />
        </a>
    </p>
<p>可扩展的hash(如下图)<br>
有一个可扩展的目录数组，相当于指针<br>
global表示全局深度，loal表示桶的局部深度<br>
如果local深度小于glocal深度，则只需要扩展local部分的，将local的桶一分为二即可<br>
查找时，根据hash函数得到的整数 y， 对y的二进制取前global位，不足的补0<br>
如下，根据hash函数和global得到 01，去01桶里面取，在桶里面挨个比较就能得到最终值了<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gg21h.png">
            <img class="mx-auto" alt="hash table-6" src="https://v1.ax1x.com/2024/05/28/7gg21h.png" />
        </a>
    </p>
<p>插入时，如果local的深度不够了，则+1，如果此时local深度 &gt; global深度，则整个 global槽位需要范围扩容<br>
扩容后需要重新做hash<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gg669.png">
            <img class="mx-auto" alt="hash table-7" src="https://v1.ax1x.com/2024/05/28/7gg669.png" />
        </a>
    </p>
<p>线性hash，如下图<br>
用一个针跟踪下一个 bucket 的分裂点<br>
当任何一个bucket溢出时，在指针点的位置做分裂<br>
对于给定的key，使用多个hash函数来找到合适的位置<br>
分裂的标准有很多，比如空间利用率、链的溢出平均长度等<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggZQY.png">
            <img class="mx-auto" alt="hash table-8" src="https://v1.ax1x.com/2024/05/28/7ggZQY.png" />
        </a>
    <br>
如上，一开始的分裂指针指向0，之后bucket1 溢出，然后将bucket0分裂<br>
将bucket0 的20重新hash，放到bucket4的链表后面</p>
<p>相关文章</p>
<ul>
<li><a href="https://github.com/efficient/libcuckoo">CMU的 cuckoo hash 实现</a></li>
<li><a href="https://github.com/apavlo/hash-function-benchmark">hash-function-benchmark</a></li>
</ul>
<h2 id="table-index">Table Index</h2>
<blockquote>
<p>A table index is a replica of a subset of a table&rsquo;s attributes that are organized and/or sorted for efficient access using those attributes.</p>
<p>The DBMS ensures that the contents of the table and the index are logically synchronized.</p>
</blockquote>
<p>DBMS根据查询计划，找到最合适的索引<br>
权衡每个创建的索引数量，存储开销、维护开销</p>
<p>B树家族</p>
<ul>
<li>B-Tree (1971)</li>
<li>B+Tree (1973)</li>
<li>B*Tree (1977?)</li>
<li>B link-Tree (1981)</li>
</ul>
<p>B+树</p>
<ul>
<li>一种自平衡的树 数据结构，维护了数据有序性</li>
<li>支持查找、顺序访问、查询、删除，时间复杂度 O(logN)</li>
<li>通过读/写 大数据块来做优化</li>
<li>完美平衡的，每个页节点都有相同的深度</li>
<li>除了root外，每个节点至少是半满的， <code>M/2-1 &lt;= #keys &lt;= M-1</code></li>
</ul>
<p>页节点的值</p>
<ul>
<li>方式1：指向 索引项对应的元组位置的指针；PG、SqlServer、DB2、Oracle</li>
<li>方式2：页节点存储真实的元组内容，二级索引以记录ID作为它的值；SQLLite、MySQL、SqlServer、Oracle</li>
</ul>
<p>查找方式，查找 index(A,B)<br>
以及查找 index(A,*)<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggdvH.png">
            <img class="mx-auto" alt="tree index-1" src="https://v1.ax1x.com/2024/05/28/7ggdvH.png" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gh9LU.png">
            <img class="mx-auto" alt="tree index-2" src="https://v1.ax1x.com/2024/05/28/7gh9LU.png" />
        </a>
    

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghBzs.png">
            <img class="mx-auto" alt="tree index-3" src="https://v1.ax1x.com/2024/05/28/7ghBzs.png" />
        </a>
    </p>
<p>INSERT</p>
<ul>
<li>找到页节点 L，将数据查询到L 中，并保持有序</li>
<li>如果L 的空间足够则返回</li>
<li>否则将L 拆分为 L和 L2，重新分布数据，以中间key作为分割点</li>
<li>在L的父节点中，增加一个指向L2的指针</li>
</ul>
<p>DELETE</p>
<ul>
<li>从root开始，找到页节点L，删除条目</li>
<li>如果L 至少是半满的，则返回</li>
<li>如果L 只有M/2-1个条目，则重新分布，从兄弟节点(相邻节点有共同父节点)借一个条目</li>
<li>如果重分布式失败，则合并L和兄弟节点</li>
<li>合并完后，从L的父节点中删除 指向L或者L兄弟的指针</li>
</ul>
<p><strong>实践中的B+树</strong></p>
<ul>
<li>填充因子 67%</li>
<li>能力，高度4： 1334 = 312900721 个条目</li>
<li>高度3：       1333 = 2406104 个条</li>
<li>每个级别的页大小</li>
<li>Level 1： 1page = 8K</li>
<li>Level2：  134pages = 1M</li>
<li>Level3： 17956pages = 140M</li>
<li>估计4级 有18G</li>
</ul>
<p>重复key的处理方式</p>
<ul>
<li>在原有key基础上，增加一个额外的标识，如page+colt信息</li>
<li>页节点溢出到一个页记录这些重复记录，但会增加维护和修改的复杂度</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghkxq.png">
            <img class="mx-auto" alt="tree index-4" src="https://v1.ax1x.com/2024/05/28/7ghkxq.png" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ggenZ.png">
            <img class="mx-auto" alt="tree index-5" src="https://v1.ax1x.com/2024/05/28/7ggenZ.png" />
        </a>
    </p>
<p>聚集索引，主键索引，没有就默认建一个 <br>
非聚集索引，找到数据页id，然后再找到具体的数据页</p>
<p>B+树 的设计选择</p>
<ul>
<li>节点大小
<ul>
<li>HDD 1M； SSD 10K；memory：512B</li>
<li>非常依赖场景</li>
<li>页节点的scan vs root-&gt;leaft的扫描 使用的大小是不同的</li>
</ul>
</li>
<li>合并的阈值
<ul>
<li>一些DBMS在页节点半满时，并不总是合并</li>
<li>延迟合并可以降低重新排列的数量</li>
<li>更好的方式：让小的节点存在，周期性的rebuild整个树</li>
</ul>
</li>
<li>可变长度key
<ul>
<li>指针：将key当做指向元组的指针，并存储</li>
<li>变长节点：索引节点的每个大小都不同，需要很好的内存管理</li>
<li>填充：总是填充key类型的最大长度</li>
<li>key map/间接的：内嵌一个指针数组，此数组映射到内节点的key+value的列表</li>
</ul>
</li>
<li>内部节点查找
<ul>
<li>线性，从头扫描到尾</li>
<li>二分查找</li>
<li>插入式，根据已知的key分布，得到想要的key的大致位置</li>
</ul>
</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghm9a.png">
            <img class="mx-auto" alt="tree index-6" src="https://v1.ax1x.com/2024/05/28/7ghm9a.png" />
        </a>
    </p>
<p>优化</p>
<ul>
<li>前缀压缩，可能有很多变种</li>
<li>去重，非唯一索引可能会存多份，可以维护一个包含key的元组列表，类似hash table那样</li>
<li>bulk insert，基于现有的table构建一颗新B+树(最快的方式)，先排序key，再字底向上构建</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghL1I.png">
            <img class="mx-auto" alt="tree index-7" src="https://v1.ax1x.com/2024/05/28/7ghL1I.png" />
        </a>
    </p>
<p>B+ 树的合并</p>
<ul>
<li>离线合并，阻塞所有操作，直到合并完</li>
<li>访问期间合并，批量合并</li>
<li>copy+merge 后台更新，应用缺失的更新</li>
<li>延迟，设置主页和其他二级页，在主页中则不更新，从对应的二级页中合并对应的key范围</li>
</ul>
<p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghpK7.jpg">
            <img class="mx-auto" alt="tree index-8" src="https://v1.ax1x.com/2024/05/28/7ghpK7.jpg" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gh06V.jpg">
            <img class="mx-auto" alt="tree index-9" src="https://v1.ax1x.com/2024/05/28/7gh06V.jpg" />
        </a>
    </p>
<p>创建部分索引，减少了I/O和管理开销，比如分区索引</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> idx_foo
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ON</span> foo (a, b)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">WHERE</span> <span style="color:#ff79c6">c</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;WuTang&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>覆盖索引，只需要查询索引即可，不需要查询tuples</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> idx_foo <span style="color:#ff79c6">ON</span> foo (a, b);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> b <span style="color:#ff79c6">FROM</span> foo <span style="color:#ff79c6">WHERE</span> a <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">123</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>内嵌索引，创建的列 c 不是索引的一部分，额外的字段存储在叶节点上</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> idx_foo <span style="color:#ff79c6">ON</span> foo (a, b) INCLUDE (<span style="color:#ff79c6">c</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> b <span style="color:#ff79c6">FROM</span> foo <span style="color:#ff79c6">WHERE</span> a <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">123</span> <span style="color:#ff79c6">AND</span> <span style="color:#ff79c6">c</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;WuTang&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数，表达式索引<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghlNL.jpg">
            <img class="mx-auto" alt="tree index-10" src="https://v1.ax1x.com/2024/05/28/7ghlNL.jpg" />
        </a>
    </p>
<p>观察：</p>
<ul>
<li>The inner node keys in a B+Tree cannot tell you whether a key exists in the index. You must always traverse to the leaf node.</li>
<li>This means that you could have (at least) one buffer pool page miss per level in the tree just to find out a key does not exist.</li>
</ul>
<p>Trie Index</p>
<ul>
<li>使用key的数字表示，来一个一个的检测前缀，而不是比较整个key</li>
<li>也叫作：Digital Search Tree、Prefix Tree

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gh7vJ.jpg">
            <img class="mx-auto" alt="tree index-11" src="https://v1.ax1x.com/2024/05/28/7gh7vJ.jpg" />
        </a>
    </li>
</ul>
<p>Trie Index 特性</p>
<ul>
<li>树的形状依赖于 key的空间和长度</li>
<li>不依赖存在的kye、或者插入顺序</li>
<li>不需要重新平衡操作</li>
<li>所有的操作需要 $O(k)$的时间复杂度，其中 k 也是 key的长度</li>
<li>到叶节点的路径表示叶的键</li>
<li>key的存储是通过一条路径来表示的</li>
</ul>
<p>Tire Key span</p>
<ul>
<li>这里的span，表示每个部分key/数字所表示的 bit数</li>
<li>如果该数字存在于这个块中，则trie分支的指针 指向下一级，否则存储空</li>
<li>这也决定了每个节点的 fan-out，以及树的物理高度</li>
<li>n-way Trie = fan-out of n 

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghqxt.jpg">
            <img class="mx-auto" alt="tree index-12" src="https://v1.ax1x.com/2024/05/28/7ghqxt.jpg" />
        </a>
    </li>
</ul>
<p>Radix Tree，前缀树主要存储字符串，基数树存储数字类型<br>
不是所有的属性类型都能分解到 radix tree的二进制比较数字中</p>
<ul>
<li>无符号整数，字节顺序必须反转为小端派</li>
<li>有符号的整数，反转两个补码，使的负数 小于 正数</li>
<li>浮点数，将其分组归类，如 负数vs正数，规范化vs非规范化</li>
<li>复合类型：转换为每个独立的属性

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghN0B.jpg">
            <img class="mx-auto" alt="tree index-13" src="https://v1.ax1x.com/2024/05/28/7ghN0B.jpg" />
        </a>
    </li>
</ul>
<p>倒排索引</p>
<ul>
<li>目前将到的 tree index，适用于 点查、范围查询</li>
<li>如查找所有zip code为15217的客户</li>
<li>查询在 2018-06 到 2018-09范围的订单</li>
<li>并不适合 keyword查询，比如查找维基百科中，包含 pavlo 的文章</li>
<li>倒排索引包含： 单词 到 目标端属性中包含这些单词的记录映射</li>
<li>也叫做：full-text search index.</li>
<li>在很古老的时代也叫做：concordance</li>
<li>很多DBMS都支持，也有专门的DBMS，如：</li>
<li>Lucene、elasticsearch、Xapian、Solr、Sphinx

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghEIG.jpg">
            <img class="mx-auto" alt="tree index-14" src="https://v1.ax1x.com/2024/05/28/7ghEIG.jpg" />
        </a>
    </li>
</ul>
<p>使用索引查询出来的并非我们想要的结果，而且效率还很差</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">CREATE</span> <span style="color:#ff79c6">INDEX</span> idx_rev_cntnt <span style="color:#ff79c6">ON</span> revisions (content);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> pageID <span style="color:#ff79c6">FROM</span> revisions <span style="color:#ff79c6">WHERE</span> content <span style="color:#ff79c6">LIKE</span> <span style="color:#f1fa8c">&#39;%Pavlo%&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>倒排索引的查询类型、设计决策</p>
<ul>
<li>短句搜索：查找包含给定顺序的单词列表 记录</li>
<li>邻近搜索：查找 N 个单词中出现两个单词的记录</li>
<li>通配符搜索：查找匹配某些正则表达式的单词记录</li>
<li>Decision #1: What To Store</li>
<li>索引需要存储每条记录中至少包含的单词，由标点符号分割</li>
<li>也可以存储频率、位置、其他元数据</li>
<li>Decision #2: When To Update</li>
<li>存储一些辅助的数据结构，以 分段更新，然后批量更新索引</li>
</ul>
<p>其他</p>
<ul>
<li>倒排索引课程 -&gt; <a href="https://boston.lti.cs.cmu.edu/classes/11-642/">CMU 11-442</a></li>
<li>这里也没有讨论 空间树索引，如 R-tree，Quad-Tree，KD-Tree</li>
<li>这些包含在课程 -&gt; <a href="http://www.cs.cmu.edu/~christos/courses/826.S17/">CMU 15-826</a></li>
</ul>
<p>相关文章</p>
<ul>
<li><a href="https://dl.acm.org/doi/10.1145/319628.319663">Efficient locking for concurrent operations on B-trees</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/356770.356776">Ubiquitous B-Tree</a></li>
<li><a href="https://book.douban.com/subject/6852740/">Modern B-Tree Techniques</a></li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/p335-sun.pdf">Online B-Tree Merging</a></li>
<li><a href="https://15445.courses.cs.cmu.edu/fall2019/slides/08-trees2.pdf">Tree Indexes Part II</a></li>
</ul>
<h2 id="index-concurrency-control">Index Concurrency Control</h2>
<p>并发控制</p>
<ul>
<li>逻辑正确性：让线程看到它期望看到的</li>
<li>物理正确性：内部的对象表示是否合理</li>
</ul>
<p>locks VS latches</p>
<ul>
<li>Protect the database&rsquo;s logical contents from other txns.</li>
<li>Held for txn duration.</li>
<li>Need to be able to rollback changes</li>
<li>Protect the critical sections of the DBMS&rsquo;s internal data structure from other threads.</li>
<li>Held for operation duration.</li>
<li>Do not need to be able to rollback changes</li>
</ul>
<p>lock vs latch的比较如下图：<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghiAB.png">
            <img class="mx-auto" alt="index concurrency control-1" src="https://v1.ax1x.com/2024/05/28/7ghiAB.png" />
        </a>
    </p>
<p>latch mode</p>
<ul>
<li>读，多个线程可以同时读相同的对象</li>
<li>如果其他线程也是读模式，则当前线程可以获得 read latch</li>
<li>写，只有一个线程可以访问对象</li>
<li>如果有任何线程有读/写latch，则当前线程无法获取</li>
</ul>
<p>latch 实现</p>
<ul>
<li>Blocking OS Mutex，依靠 pthread_mutex_t 实现加锁</li>
<li>Test-and-Set Spin Latch，通过CAS的方式加锁</li>
<li>Reader-Writer Latches，必须要有读/写队列避免饥饿，可以用spin latch来实现</li>
</ul>
<p>mutex lock的实现<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghIMJ.png">
            <img class="mx-auto" alt="index concurrency control-2" src="https://v1.ax1x.com/2024/05/28/7ghIMJ.png" />
        </a>
    </p>
<p>cas 实现<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghnDL.png">
            <img class="mx-auto" alt="index concurrency control-3" src="https://v1.ax1x.com/2024/05/28/7ghnDL.png" />
        </a>
    </p>
<p>读写锁<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghjqV.png">
            <img class="mx-auto" alt="index concurrency control-4" src="https://v1.ax1x.com/2024/05/28/7ghjqV.png" />
        </a>
    </p>
<p>hash table latch</p>
<ul>
<li>因为限制了访问方式，所以控制并发也容易了</li>
<li>只能在同一时间访问单个 页面/slot</li>
<li>不可能出现死锁</li>
<li>为支持扩容，需要有一个全局写锁</li>
<li>page latch，每个页都有它自己的读/写latch，请求只能获得一个读、后者写锁</li>
<li>solt latch，每个slot都有它自己的锁</li>
</ul>
<p>page latch<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghJFI.png">
            <img class="mx-auto" alt="index concurrency control-5" src="https://v1.ax1x.com/2024/05/28/7ghJFI.png" />
        </a>
    </p>
<p>slot latch<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghf3G.png">
            <img class="mx-auto" alt="index concurrency control-6" src="https://v1.ax1x.com/2024/05/28/7ghf3G.png" />
        </a>
    </p>
<p>B+树的并发控制</p>
<ul>
<li>让多个线程同时读、更新B+树，两种类型问题</li>
<li>相同时间，线程修改节点的内容</li>
<li>一个线程在遍历树、另一个线程在split/merge树</li>
<li>Get latch for parent</li>
<li>Get latch for child</li>
<li>Release latch for parent if “safe”</li>
<li>A safe node is one that will not split or merge when updated.</li>
<li>Not full (on insertion)</li>
<li>More than half-full (on deletion)</li>
</ul>
<p>latch 的捕获/耦合</p>
<ul>
<li>find，从root开始下降，获取 R latch on child，Then unlatch parent</li>
<li>delete/insert，从root开始下降，按需获取W latch，一旦child被锁住检查是否安全</li>
<li>一旦孩子是安全的，则释放所有祖先</li>
</ul>
<p>B+树 读 latch过程，给当前节点加锁，再给子节点加锁，之后释放父节点的锁   <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghsCt.png">
            <img class="mx-auto" alt="index concurrency control-7" src="https://v1.ax1x.com/2024/05/28/7ghsCt.png" />
        </a>
    </p>
<p>B+树的删除，自顶向下，给子节点加锁，如果子节点不会被merge，则表示安全，可以将父节点的锁释放<br>
如果子节点不能确定自身是否会merge，则需要继续往下递归执行到孙子节点，给孙子加锁<br>
下图中孙子不会merge，则释放它上面的父节点，父节点的父节点锁<br>
可能比较糟糕的情况是，一直从 root到页节点都在加锁，直到页节点才能确定结果，释放所有祖先的锁<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7gh6Bb.png">
            <img class="mx-auto" alt="index concurrency control-8" src="https://v1.ax1x.com/2024/05/28/7gh6Bb.png" />
        </a>
    </p>
<p>B+树的插入，自顶向下，因为插入会导致split<br>
由于担心子节点可能要分离，当前节点就需要留出一定的空间<br>
如下，B有足够的空间，即使子节点分离也不用担心，所以可以释放父节点的锁<br>
但由于不知道哪一层会split，所以一直往下都在加锁，直到页节点确定了不会split，则可以释放祖先的锁

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghFbe.png">
            <img class="mx-auto" alt="index concurrency control-9" src="https://v1.ax1x.com/2024/05/28/7ghFbe.png" />
        </a>
    </p>
<p>另一个insert的例子，插入25，一路下来，各个中间几点都有足够的空间，于是都释放锁了<br>
直到倒数第二个节点，因为担心子节点会split，所以不能释放锁<br>
而子节点真是要split了，split后生成了新的节点 <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghZRP.png">
            <img class="mx-auto" alt="index concurrency control-10" src="https://v1.ax1x.com/2024/05/28/7ghZRP.png" />
        </a>
    </p>
<p>B+ 树的并发优化</p>
<ul>
<li>insert、delete操作，每次都是从root开始，都需要一个对root做写锁</li>
<li>并发情况下，效率会很低的</li>
<li>大多数情况下并不会发生 split、merge</li>
<li>先使用 读锁乐观的执行，如果出错，则使用悲观方式重新执行一次</li>
<li>对于 search，跟之前的一样</li>
<li>对于insert/delete，先找到页节点，对其枷锁</li>
<li>如果页节点 不是安全的，释放所有latch，按照之前的模式重新来一遍</li>
<li>这种方式假设只是 页节点需要修改，如果不是那么前面的 R latch就浪费了</li>
</ul>
<p>相关文章</p>
<ul>
<li><a href="https://www.realworldtech.com/forum/?threadid=189711&amp;curpostid=189723">No nuances, just buggy code (was: related to Spinlock implementation and the Linux Scheduler)</a></li>
<li><a href="https://link.springer.com/article/10.1007/BF00263762">Concurrency of operations on B-trees</a></li>
<li><a href="https://wenku.baidu.com/view/334a26cc9a8fcc22bcd126fff705cc1755275fdf.html">CMU-15445LAB2：实现一个支持并发操作的B+树</a></li>
<li><a href="https://www.jianshu.com/p/8941b5f0cd9c">并发b+树协议.</a></li>
<li><a href="https://blog.csdn.net/obvious__/article/details/120538190">PostgreSQL B+树索引&mdash;并发控制</a></li>
<li><a href="">Online B-Tree merging</a></li>
</ul>
<h2 id="sorting--aggregations">Sorting + Aggregations</h2>
<p>一个查询计划的例子<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g89DO.png">
            <img class="mx-auto" alt="sort_agg_1" src="https://v1.ax1x.com/2024/05/28/7g89DO.png" />
        </a>
    </p>
<p>为什么需要排序</p>
<ul>
<li>关系模型SQL是未排序的</li>
<li>指定的语句 order by需要排序</li>
<li>支持去重的 DISTINCT</li>
<li>需要批量排序后导入</li>
<li>聚合 group by</li>
</ul>
<p>外排序</p>
<ul>
<li>不能假设内存足够</li>
<li>使用分治合并的方式</li>
<li>两路归并需要3个 buffer pool page，两个输入页，一个输出页</li>
<li>即使有更多的buffer pool page，可能也不会更有效，因为工作都阻塞在I/O上了</li>
<li>优化方式，使用 double buffer</li>
<li>当系统正在处理当前一轮时，在后台预先抓取下一个轮并放入第二个buffer中</li>
</ul>
<p>两路归并的例子<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8kfQ.png">
            <img class="mx-auto" alt="sort_agg_2" src="https://v1.ax1x.com/2024/05/28/7g8kfQ.png" />
        </a>
    <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8T3f.png">
            <img class="mx-auto" alt="sort_agg_3" src="https://v1.ax1x.com/2024/05/28/7g8T3f.png" />
        </a>
    </p>
<p>108个pages，5个buffer pool执行的例子   <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghdZw.png">
            <img class="mx-auto" alt="sort_agg_4" src="https://v1.ax1x.com/2024/05/28/7ghdZw.png" />
        </a>
    </p>
<p>使用B+树索引加速排序</p>
<ul>
<li>聚集索引，通过索引找到最左边的 page，然后顺序往后遍历即可，比外部排序要高效很多</li>
<li>非聚集索引，需要回表，效率就低很多了</li>
</ul>
<p>aggreation</p>
<blockquote>
<p>Collapse values for a single attribute from multiple tuples into a single scalar value.</p>
</blockquote>
<p>aggreation的两种实现</p>
<ul>
<li>sorting</li>
<li>hashing</li>
</ul>
<p>以下SQL，通过sorting来执行</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> <span style="color:#ff79c6">DISTINCT</span> cid <span style="color:#ff79c6">FROM</span> enrolled <span style="color:#ff79c6">WHERE</span> grade <span style="color:#ff79c6">IN</span> (<span style="color:#f1fa8c">&#39;B&#39;</span>,<span style="color:#f1fa8c">&#39;C&#39;</span>) <span style="color:#ff79c6">ORDER</span> <span style="color:#ff79c6">BY</span> cid
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行过程图：</p>
<ul>
<li>先filter，过滤数据</li>
<li>再去掉多余的列</li>
<li>排序，然后再去重<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7ghoq6.png">
            <img class="mx-auto" alt="sort_agg_5" src="https://v1.ax1x.com/2024/05/28/7ghoq6.png" />
        </a>
    </li>
</ul>
<p>用hash替代排序</p>
<ul>
<li>distinct，只需要去重，其实不用排序</li>
<li>group by，只需要分组，也不用排序</li>
<li>如果临时的hash table能放入内存，则很容易，否则需要溢出到磁盘</li>
<li>分区，根据key将数据放入不同的分区，然后写回到磁盘</li>
<li>根据每个分区，建立内存的hash表，然后计算聚合</li>
<li>rehash阶段，存储一个 (GroupKey→RunningVal)</li>
<li>如果匹配了 group by key，则更新 runingVal内容，否则新建一个(GroupKey→RunningVal)</li>
</ul>
<p>阶段一，partition的例子，根据 h1 哈希函数，做分区     <br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8mAc.png">
            <img class="mx-auto" alt="sort_agg_6" src="https://v1.ax1x.com/2024/05/28/7g8mAc.png" />
        </a>
    </p>
<p>阶段二，rehash例子，根据 h2 哈希函数，做计算<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8pJ3.png">
            <img class="mx-auto" alt="sort_agg_7" src="https://v1.ax1x.com/2024/05/28/7g8pJ3.png" />
        </a>
    </p>
<p>一个例子的总结</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff79c6">SELECT</span> cid, <span style="color:#ff79c6">AVG</span>(s.gpa) <span style="color:#ff79c6">FROM</span> student <span style="color:#ff79c6">AS</span> s, enrolled <span style="color:#ff79c6">AS</span> e <span style="color:#ff79c6">WHERE</span> s.sid <span style="color:#ff79c6">=</span> e.sid <span style="color:#ff79c6">GROUP</span> <span style="color:#ff79c6">BY</span> cid
</span></span></code></pre></td></tr></table>
</div>
</div><p>先根据 h1 函数建立分区，然后遍历分区，对每个分区执行 h2函数，key是 cid，value是 (个数，分数总和)， 最后执行 (分数综合/个数) 即可求出平均值<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g80Bj.png">
            <img class="mx-auto" alt="sort_agg_8" src="https://v1.ax1x.com/2024/05/28/7g80Bj.png" />
        </a>
    </p>
<h2 id="joins-algorithms">Joins Algorithms</h2>
<p>join算法有很多优化，但没有哪个算法适用所有场景 <br>
join的花费分析标准<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8NO9.png">
            <img class="mx-auto" alt="join-1" src="https://v1.ax1x.com/2024/05/28/7g8NO9.png" />
        </a>
    </p>
<p>join类型</p>
<ul>
<li>nested loop join</li>
<li>simple/stupid</li>
<li>block</li>
<li>index</li>
<li>sort-merge join</li>
<li>hash join</li>
</ul>
<p>simple nested loop join的问题</p>
<ul>
<li>外层M 个页，m tuples；内层 N个页，n tuples</li>
<li>cost: M + (m * N)<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8Quh.png">
            <img class="mx-auto" alt="join-2" src="https://v1.ax1x.com/2024/05/28/7g8Quh.png" />
        </a>
    </li>
</ul>
<p>block nested loop join是一次刦一个page，这样总的I/O就比simple要少很多<br>
cost： M + (M * N)</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>foreach block BR ∈ R:
</span></span><span style="display:flex;"><span>    foreach block BS ∈ S:
</span></span><span style="display:flex;"><span>        foreach <span style="color:#8be9fd;font-style:italic">tuple</span> r ∈ BR:
</span></span><span style="display:flex;"><span>            foreach <span style="color:#8be9fd;font-style:italic">tuple</span> s ∈ Bs:
</span></span><span style="display:flex;"><span>                emit, <span style="color:#ff79c6">if</span> r <span style="color:#ff79c6">and</span> s match
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果有 B 个buffer，那么 B - 2个用于扫描外表，1个扫描内表，一个输出<br>
cost：M + ((M/B-2) * N)<br>
如果内层足够大，B &gt; M + 2？<br>
cost：M + N = 1000 +500 = 1500 IOs，每次I/O 0.1ms，总时间为 0.15秒<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g83g5.png">
            <img class="mx-auto" alt="join-3" src="https://v1.ax1x.com/2024/05/28/7g83g5.png" />
        </a>
    </p>
<p>index nested loop join</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>foreach <span style="color:#8be9fd;font-style:italic">tuple</span> r ∈ R:
</span></span><span style="display:flex;"><span>    foreach <span style="color:#8be9fd;font-style:italic">tuple</span> s ∈ Index(ri <span style="color:#ff79c6">=</span> sj):
</span></span><span style="display:flex;"><span>        emit, <span style="color:#ff79c6">if</span> r <span style="color:#ff79c6">and</span> s match
</span></span></code></pre></td></tr></table>
</div>
</div><p>nested loop join总结</p>
<ul>
<li>让小表当做外部表</li>
<li>尽可能让外部表全放入内存中</li>
<li>loop遍历内部表尽可能使用索引</li>
<li>三种算法：simple/stupid、block、index</li>
<li>目前讨论的都是两路join，也有多路join，同时多个表做关联，但这个方式只是出现在理论中<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8lYm.png">
            <img class="mx-auto" alt="join-4" src="https://v1.ax1x.com/2024/05/28/7g8lYm.png" />
        </a>
    </li>
</ul>
<p>sort-merge join</p>
<ul>
<li>先排序，按照 join 的key排序，使用外部排序</li>
<li>在合并，使用双指针迭代，必要时可能需要回溯</li>
<li>Sort Cost (R): 2M ∙ (1 + logB-1[M / B])</li>
<li>Sort Cost (S): 2N ∙ (1 + ⌈ logB-1[N / B])</li>
<li>Merge Cost: (M + N)</li>
<li>Total Cost: Sort + Merge</li>
<li>最坏的情况是，两个关系的所有元组的join属性包含相同值</li>
<li>Cost: (M ∙ N) + (sort cost)</li>
<li>当join之前，两个表中的一个或者两个已经有序了，这时效率就比较高了</li>
<li>输入端关系可以通过显示的排序算子，or by scanning the relation using an index on the join key

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g87Z4.png">
            <img class="mx-auto" alt="join-5" src="https://v1.ax1x.com/2024/05/28/7g87Z4.png" />
        </a>
    </li>
</ul>
<p>sort-merge join算法：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sort R,S on join keys
</span></span><span style="display:flex;"><span>cursorR ← Rsorted, cursorS ← Ssorted
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">while</span> cursorR <span style="color:#ff79c6">and</span> cursorS:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> cursorR <span style="color:#ff79c6">&gt;</span> cursorS:
</span></span><span style="display:flex;"><span>        increment cursorS
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> cursorR <span style="color:#ff79c6">&lt;</span> cursorS:
</span></span><span style="display:flex;"><span>        increment cursorR
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">elif</span> cursorR <span style="color:#ff79c6">and</span> cursorS match:
</span></span><span style="display:flex;"><span>        emit
</span></span><span style="display:flex;"><span>        increment cursorS
</span></span></code></pre></td></tr></table>
</div>
</div><p>join hash</p>
<ul>
<li>如果基于 i 做分区，那么 R tuple 肯定属于 Ri，S tuple 属于Si</li>
<li>因此，Ri 只需要跟 Si 比较即可</li>
<li>首先基于外表建立一个hash表，使用 h1 函数对join属性做hash</li>
<li>用h1 函数扫描内部表，查看是否有hash 表的值能跟其匹配</li>
<li>hash表的key是查询的join条件</li>
<li>Depends on what the operators above the join in the query plan expect as its input.

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8wlH.png">
            <img class="mx-auto" alt="join-6" src="https://v1.ax1x.com/2024/05/28/7g8wlH.png" />
        </a>
    </li>
</ul>
<p>hash table values</p>
<ul>
<li>full tuple，避免在匹配的时检索外部表，需要更多的内存</li>
<li>tupe identifier</li>
<li>Could be to either the base tables or the intermediate output from child operators in the query plan.</li>
<li>探测阶段可以使用 bloom filter优化</li>
<li>sideways information passing</li>
</ul>
<p>bloom filter cost analysis<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8qfY.png">
            <img class="mx-auto" alt="join-7" src="https://v1.ax1x.com/2024/05/28/7g8qfY.png" />
        </a>
    </p>
<p>grace hash join</p>
<ul>
<li>当内存不足放下整个hash 表时，可以采用这种方式</li>
<li>将连接跳上的两个表通过hash，打散到分区中</li>
<li>比较每个表对应分区的tuples</li>
</ul>
<p>grace hash join比较 对应的两个分区</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>foreach <span style="color:#8be9fd;font-style:italic">tuple</span> r ∈ bucketR,<span style="color:#bd93f9">0</span>:
</span></span><span style="display:flex;"><span>    foreach <span style="color:#8be9fd;font-style:italic">tuple</span> s ∈ bucketS,<span style="color:#bd93f9">0</span>:
</span></span><span style="display:flex;"><span>        emit, <span style="color:#ff79c6">if</span> match(r, s)
</span></span></code></pre></td></tr></table>
</div>
</div><p>
        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8yAZ.png">
            <img class="mx-auto" alt="join-8" src="https://v1.ax1x.com/2024/05/28/7g8yAZ.png" />
        </a>
    </p>
<p>如果分区无法放入内存，则用 h2函数，继续递归的对这个分区再分区<br>
如下，对 S 表的分区1，因为跟R的分区1 层级匹配，则也执行h2函数，跟R1.1&rsquo;，R1.1&rsquo;&rsquo;，R1.1&rsquo;&rsquo;&rsquo; 匹配<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8HJU.png">
            <img class="mx-auto" alt="join-9" src="https://v1.ax1x.com/2024/05/28/7g8HJU.png" />
        </a>
    </p>
<p>grace hash join</p>
<ul>
<li>cost： 3(M + N)</li>
<li>partitioning phase： 2(M + N)</li>
<li>probing phase：  M + N

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8bTq.png">
            <img class="mx-auto" alt="join-10" src="https://v1.ax1x.com/2024/05/28/7g8bTq.png" />
        </a>
    </li>
</ul>
<p>如果DBMS知道外部表的大小，可以使用静态hash，这样就省去了额外的build、probe操作<br>
如果不知道表大小，则必须使用动态hash，或者允许页溢出<br>
hash算法总结<br>

        <a data-fancybox="gallery" href="https://v1.ax1x.com/2024/05/28/7g8ggs.png">
            <img class="mx-auto" alt="join-11" src="https://v1.ax1x.com/2024/05/28/7g8ggs.png" />
        </a>
    </p>
<p>相关文章</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter">bloom filter</a></li>
<li><a href="https://en.wikipedia.org/wiki/Database_machine">Grace hash database machine</a></li>
<li><a href="http://museum.ipsj.or.jp/en/computer/other/0014.html">GRACE Parallel Relational Database Machine</a></li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://doxygen.postgresql.org/index.html">PostgreSQL在线源码</a></li>
<li><a href="https://db.cs.cmu.edu/seminar2021-dose2/">数据库技术讲座</a></li>
<li><a href="https://db.cs.cmu.edu/">数据库部门</a></li>
<li><a href="https://www.pdl.cmu.edu/index.shtml">并行数据研究室</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/418225728">知乎的CMU数据库课程学习记录</a></li>
<li><a href="https://zhmin.github.io/">PG内部实现</a></li>
<li><a href="https://boston.lti.cs.cmu.edu/classes/11-642/">Search Engines</a></li>
<li><a href="http://www.cs.cmu.edu/~christos/courses/826.S17/">Multimedia Databases and Data Mining</a></li>
<li><a href="http://justinlevandoski.org/">http://justinlevandoski.org/</a></li>
</ul>

			<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
        </div>

        


        

<div class="post-archive">
    <h2>相关文章</h2>
    <ul class="listing">
        
        <li><a href="/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B-2/">卡内基梅隆的数据库课程-2</a></li>
        
        <li><a href="/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B-3/">卡内基梅隆的数据库课程-3</a></li>
        
        <li><a href="/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B-4/">卡内基梅隆的数据库课程-4</a></li>
        
        <li><a href="/post/2022/07/cmu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B-5/">卡内基梅隆的数据库课程-5</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/cmu-database'>CMU-Database</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "himichael/hugoblogtalks"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>


                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://code0xff.org/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://code0xff.org/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://code0xff.org/post/2025/01/spark_register_source/" title="Spark 注册数据源">Spark 注册数据源</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2025/01/spark_core_2/" title="Spark Core相关-2">Spark Core相关-2</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2024/12/llamafactory/" title="Llama Factory">Llama Factory</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2024/11/spark_core/" title="Spark Core相关-1">Spark Core相关-1</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2024/11/sae_tunnel/" title="sea tunnel">sea tunnel</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2024/11/k8s_networks/" title="k8s 网络">k8s 网络</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2024/11/ozone/" title="ozone">ozone</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2024/11/es/" title="ES的简单学习">ES的简单学习</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2025/02/ai/" title="AI的简单学习">AI的简单学习</a>
    </li>
    
    <li>
        <a href="https://code0xff.org/post/2024/11/big_data_investigation/" title="国内几个云厂商大数据平台">国内几个云厂商大数据平台</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://code0xff.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式 (6)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">原理分析 (24)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E5%95%86%E4%B8%9A/">商业 (3)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据 (56)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库 (41)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%96%87%E5%AD%A6%E5%92%8C%E8%89%BA%E6%9C%AF/">文学和艺术 (3)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%97%85%E8%A1%8C/">旅行 (12)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E6%9E%B6%E6%9E%84/">架构 (13)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E7%AE%97%E6%B3%95/">算法 (8)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E7%B3%BB%E7%BB%9F/">系统 (7)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言 (7)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E8%A1%8C%E4%B8%9A%E8%A7%82%E5%AF%9F/">行业观察 (3)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 (14)</a></li>
    
    <li><a href="https://code0xff.org/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/">随便写写 (3)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">归档</a></h3>
<ul class="widget-list">
    
    <li><a href="https://code0xff.org/years/2021%E5%B9%B4/">2021年 (41)</a></li>
    
    <li><a href="https://code0xff.org/years/2022%E5%B9%B4/">2022年 (55)</a></li>
    
    <li><a href="https://code0xff.org/years/2023%E5%B9%B4/">2023年 (54)</a></li>
    
    <li><a href="https://code0xff.org/years/2024%E5%B9%B4/">2024年 (48)</a></li>
    
    <li><a href="https://code0xff.org/years/2025%E5%B9%B4/">2025年 (2)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://code0xff.org/tags/ai/">AI </a>
    
    <a href="https://code0xff.org/tags/ambari/">Ambari </a>
    
    <a href="https://code0xff.org/tags/architecture/">architecture </a>
    
    <a href="https://code0xff.org/tags/bigdata/">bigdata </a>
    
    <a href="https://code0xff.org/tags/b%E6%A0%91/">B树 </a>
    
    <a href="https://code0xff.org/tags/c&#43;&#43;/">C&#43;&#43; </a>
    
    <a href="https://code0xff.org/tags/calcite/">calcite </a>
    
    <a href="https://code0xff.org/tags/cmu-database/">CMU-Database </a>
    
    <a href="https://code0xff.org/tags/data_ingestion/">Data_Ingestion </a>
    
    <a href="https://code0xff.org/tags/deltalake/">DeltaLake </a>
    
    <a href="https://code0xff.org/tags/doris/">Doris </a>
    
    <a href="https://code0xff.org/tags/english/">English </a>
    
    <a href="https://code0xff.org/tags/es/">ES </a>
    
    <a href="https://code0xff.org/tags/facebook/">Facebook </a>
    
    <a href="https://code0xff.org/tags/flink/">flink </a>
    
    <a href="https://code0xff.org/tags/flume/">flume </a>
    
    <a href="https://code0xff.org/tags/gc/">GC </a>
    
    <a href="https://code0xff.org/tags/gluten/">Gluten </a>
    
    <a href="https://code0xff.org/tags/hana/">HANA </a>
    
    <a href="https://code0xff.org/tags/hive/">Hive </a>
    
    <a href="https://code0xff.org/tags/iceberg/">iceberg </a>
    
    <a href="https://code0xff.org/tags/impala/">Impala </a>
    
    <a href="https://code0xff.org/tags/janino/">janino </a>
    
    <a href="https://code0xff.org/tags/k8s/">k8s </a>
    
    <a href="https://code0xff.org/tags/kafka/">Kafka </a>
    
    <a href="https://code0xff.org/tags/kudu/">kudu </a>
    
    <a href="https://code0xff.org/tags/kyuubi/">Kyuubi </a>
    
    <a href="https://code0xff.org/tags/lakehouse/">Lakehouse </a>
    
    <a href="https://code0xff.org/tags/leveldb/">LevelDB </a>
    
    <a href="https://code0xff.org/tags/llamafactory/">LlamaFactory </a>
    
    <a href="https://code0xff.org/tags/llvm/">LLVM </a>
    
    <a href="https://code0xff.org/tags/manacher/">Manacher </a>
    
    <a href="https://code0xff.org/tags/mapreduce/">MapReduce </a>
    
    <a href="https://code0xff.org/tags/micro-service/">micro-service </a>
    
    <a href="https://code0xff.org/tags/mysql/">MySQL </a>
    
    <a href="https://code0xff.org/tags/newsql/">NewSQL </a>
    
    <a href="https://code0xff.org/tags/oceanbase/">OceanBase </a>
    
    <a href="https://code0xff.org/tags/openlogreplicator/">OpenLogReplicator </a>
    
    <a href="https://code0xff.org/tags/parquet/">parquet </a>
    
    <a href="https://code0xff.org/tags/paxos/">paxos </a>
    
    <a href="https://code0xff.org/tags/presto/">Presto </a>
    
    <a href="https://code0xff.org/tags/quick-sql/">quick-sql </a>
    
    <a href="https://code0xff.org/tags/raft/">raft </a>
    
    <a href="https://code0xff.org/tags/scala/">scala </a>
    
    <a href="https://code0xff.org/tags/simd/">SIMD </a>
    
    <a href="https://code0xff.org/tags/snowflake/">snowflake </a>
    
    <a href="https://code0xff.org/tags/spark/">spark </a>
    
    <a href="https://code0xff.org/tags/sre/">SRE </a>
    
    <a href="https://code0xff.org/tags/teradata/">TeraData </a>
    
    <a href="https://code0xff.org/tags/tpcx-hs/">TPCx-HS </a>
    
    <a href="https://code0xff.org/tags/trino/">Trino </a>
    
    <a href="https://code0xff.org/tags/tuning/">Tuning </a>
    
    <a href="https://code0xff.org/tags/unix/">unix </a>
    
    <a href="https://code0xff.org/tags/yarn/">YARN </a>
    
    <a href="https://code0xff.org/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找 </a>
    
    <a href="https://code0xff.org/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">二叉树遍历 </a>
    
    <a href="https://code0xff.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式 </a>
    
    <a href="https://code0xff.org/tags/%E5%88%97%E5%AD%98/">列存 </a>
    
    <a href="https://code0xff.org/tags/%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5/">动态注入 </a>
    
    <a href="https://code0xff.org/tags/%E5%8E%86%E5%8F%B2/">历史 </a>
    
    <a href="https://code0xff.org/tags/%E5%90%91%E9%87%8F%E5%8C%96/">向量化 </a>
    
    <a href="https://code0xff.org/tags/%E5%9B%9E%E6%BA%AF/">回溯 </a>
    
    <a href="https://code0xff.org/tags/%E5%9B%BD%E5%86%85%E6%97%85%E8%A1%8C/">国内旅行 </a>
    
    <a href="https://code0xff.org/tags/%E5%9B%BD%E5%A4%96%E6%97%85%E8%A1%8C/">国外旅行 </a>
    
    <a href="https://code0xff.org/tags/%E5%A4%9A%E7%A7%9F%E6%88%B7/">多租户 </a>
    
    <a href="https://code0xff.org/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据 </a>
    
    <a href="https://code0xff.org/tags/%E5%AD%98%E5%82%A8/">存储 </a>
    
    <a href="https://code0xff.org/tags/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/">工作记录 </a>
    
    <a href="https://code0xff.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务 </a>
    
    <a href="https://code0xff.org/tags/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/">数据中台 </a>
    
    <a href="https://code0xff.org/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库 </a>
    
    <a href="https://code0xff.org/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/">数据模型 </a>
    
    <a href="https://code0xff.org/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/">数据迁移 </a>
    
    <a href="https://code0xff.org/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">查询优化 </a>
    
    <a href="https://code0xff.org/tags/%E6%9F%A5%E8%AF%A2%E7%BC%96%E8%AF%91/">查询编译 </a>
    
    <a href="https://code0xff.org/tags/%E6%A6%82%E7%8E%87/">概率 </a>
    
    <a href="https://code0xff.org/tags/%E6%B1%87%E7%BC%96/">汇编 </a>
    
    <a href="https://code0xff.org/tags/%E6%B5%8B%E8%AF%95/">测试 </a>
    
    <a href="https://code0xff.org/tags/%E7%94%9F%E6%B4%BB/">生活 </a>
    
    <a href="https://code0xff.org/tags/%E7%94%B5%E5%BD%B1/">电影 </a>
    
    <a href="https://code0xff.org/tags/%E7%AE%97%E6%B3%95/">算法 </a>
    
    <a href="https://code0xff.org/tags/%E7%B4%A2%E5%BC%95/">索引 </a>
    
    <a href="https://code0xff.org/tags/%E7%BB%8F%E6%B5%8E/">经济 </a>
    
    <a href="https://code0xff.org/tags/%E7%BC%93%E5%AD%98/">缓存 </a>
    
    <a href="https://code0xff.org/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理 </a>
    
    <a href="https://code0xff.org/tags/%E7%BD%91%E7%BB%9C/">网络 </a>
    
    <a href="https://code0xff.org/tags/%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/">计算框架 </a>
    
    <a href="https://code0xff.org/tags/%E8%AE%BA%E6%96%87/">论文 </a>
    
    <a href="https://code0xff.org/tags/%E8%AF%BB%E4%B9%A6/">读书 </a>
    
    <a href="https://code0xff.org/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 </a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">RSS</h3>
        <ul class="widget-list">
            <li><a href="https://code0xff.org/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div>
        &copy; 2025 <a href="https://code0xff.org/">记录每个瞬间 By 老王</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'GA ID', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>

</html>